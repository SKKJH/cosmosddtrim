/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "hil.h"

#include "dftl_internal.h"

DFTL_GLOBAL* DFTL_GLOBAL::m_pstInstance;

VOID DFTL_GLOBAL::WritePtr_GetAndAdvance(UINT32 clusterID)
{
    m_page_cnt[clusterID]++;
    if (m_page_cnt[clusterID] >= LPN_PER_PHYSICAL_PAGE) {
        m_page_cnt[clusterID] = 0;
        m_wp_ch[clusterID]++;
        if (m_wp_ch[clusterID] >= USER_CHANNELS) {
            m_wp_ch[clusterID] = 0;
            m_wp_wy[clusterID]++;
            if (m_wp_wy[clusterID] >= USER_WAYS) {
                m_wp_wy[clusterID] = 0;
            }
        }
    }
}

VOID DFTL_GLOBAL::GC_WritePtr_GetAndAdvance(UINT32 clusterID)
{
    m_gc_page_cnt[clusterID]++;
    if (m_gc_page_cnt[clusterID] >= LPN_PER_PHYSICAL_PAGE) {
        m_gc_page_cnt[clusterID] = 0;
        m_gc_wp_ch[clusterID]++;
        if (m_gc_wp_ch[clusterID] >= USER_CHANNELS) {
            m_gc_wp_ch[clusterID] = 0;
            m_gc_wp_wy[clusterID]++;
            if (m_gc_wp_wy[clusterID] >= USER_WAYS) {
                m_gc_wp_wy[clusterID] = 0;
            }
        }
    }
}

VOID DFTL_GLOBAL::DebugBlockPrint(UINT32 FLAG)
{
    GetUserBlockMgr()->DebugPrintAllByVBN(FLAG);
}

UINT32 DFTL_GLOBAL::GetClusterID(UINT32 LPN)
{
    UINT64 num   = (UINT64)LPN * (UINT64)USER_CLUSTERS;
    UINT32 cid   = (UINT32)(num / (UINT64)m_nLPNCount);

    if (cid >= USER_CLUSTERS)
    {
    	xil_printf("Wrong CID\r\n");
    	assert(0);
    }

//    xil_printf("	[MAKE] LPN:%u, CLUSTER ID:%u\r\n", LPN, cid);

    return cid;
}

VOID DFTL_GLOBAL::SB_INIT()
{
    SBINFO_MGR* sbm = GetSBInfoMgr();
    INT32 c = DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();

    // 프리 리스트 헤드 초기화 및 카운터 리셋
    INIT_LIST_HEAD(&sbm->m_dlFreeList);
    sbm->m_nFreeCount = 0;

    for (INT32 vbn = 0; vbn < c; vbn++)
    {
        SBINFO* sb = &sbm->m_pastSBInfo[vbn];

        // 방어적으로 리스트 노드 초기화 (기존 연결 제거)
        INIT_LIST_HEAD(&sb->m_dlList);

        // 제외: BAD 이거나 VBN <= 20 (메타 예약 구간)
        if (sb->m_bBad != 0)  	continue;
        if (sb->m_bMeta)		continue;

        // 프리 조건: 아직 사용 중이 아니어야 함
        if (sb->m_nUSED != 0) continue;

        // 프리 리스트에 push
        list_add_tail(&sb->m_dlList, &sbm->m_dlFreeList);
        sbm->m_nFreeCount++;
    }

    {
        UINT32 freeWalk = 0, badInFree = 0, metaInFree = 0, usedInFree = 0;

        PRINTF("[SB_INIT] ===== FREE SB LIST START =====\n\r");
        SBINFO* pos;
        list_for_each_entry(SBINFO, pos, &sbm->m_dlFreeList, m_dlList) {
//            PRINTF("[SB_INIT][FREE] VBN:%u, USED:%u, BAD:%u, META:%u\n\r",
//                   pos->m_nVBN, pos->m_nUSED, pos->m_bBad, pos->m_bMeta);
            freeWalk++;

            if (pos->m_bBad)  badInFree++;
            if (pos->m_bMeta) metaInFree++;
            if (pos->m_nUSED) usedInFree++;
        }
        PRINTF("[SB_INIT] FREE COUNT (walked): %u\n\r", freeWalk);
        PRINTF("[SB_INIT] FREE COUNT (sbm->m_nFreeCount): %u\n\r", sbm->m_nFreeCount);
        if (badInFree || metaInFree || usedInFree) {
            PRINTF("[SB_INIT][WARN] bad:%u, meta:%u, used:%u entries wrongly in FREE list!\n\r",
                   badInFree, metaInFree, usedInFree);
        }
        PRINTF("[SB_INIT] ===== FREE SB LIST END =====\n\r");
    }
    SB_INIT_FLAG = TRUE;
}


VIRTUAL VOID 
DFTL_GLOBAL::Initialize(VOID)
{
	DS_CNT = 0;
	DS_Length = 0;
	SB_INIT_FLAG = FALSE;
    SB_PRINT_FLAG = FALSE;
	META_CNT = 0;

	for (int i=0; i<USER_CLUSTERS; i++)
	{
		m_util_pages[i] = 0;
		m_util_blks[i] = 0;

		m_wp_ch[i] = 0;
		m_wp_wy[i] = 0;
		m_page_cnt[i] = 0;

		m_gc_wp_ch[i] = 0;
		m_gc_wp_wy[i] = 0;
		m_gc_page_cnt[i] = 0;
	}

//	m_ActiveBlockAllocCnt = USER_CHANNELS * USER_WAYS;
//	m_GCActiveBlockAllocCnt = USER_CHANNELS * USER_WAYS;

	m_pstInstance = this;
	_Initialize();
	GetVNandMgr()->Initialize();
	GetMetaMgr()->Initialize();
	GetMetaL2VMgr()->Initialize();

	TrimBitmap_Init();
	TrimPending_Clear();

	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			GetVBInfoMgr(channel, way)->Initialize();
		}
	}
	GetUserBlockMgr()->Initialize(USER_BLOCK_MGR);		// must be formantted before meta block mgr
#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Initialize(META_BLOCK_MGR);
#endif
	GetRequestMgr()->Initialize();
	GetBufferMgr()->Initialize();
	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			for (int cluster = 0; cluster < USER_CLUSTERS; cluster++)
			{
				GetActiveBlockMgr(cluster, channel, way)->Initialize(cluster, channel, way);
			}
			GetGCMgr(channel, way)->Initialize(GetGCTh(), IOTYPE_GC, channel, way);
#if (SUPPORT_META_DEMAND_LOADING == 1)
			GetMetaGCMgr(channel, way)->Initialize(META_GC_THRESHOLD, IOTYPE_META, channel, way);
#endif
		}
	}
	_PrintInfo();
	m_MetaGCing = FALSE;

	GetReadCacheMgr()->Initialize();
	GetSBInfoMgr()->Initialize();
}



#define TRIM_BITMAP_BYTES ((TOTAL_LPN_COUNT + 7ull) / 8ull)
#ifndef TRIM_BITMAP_ALIGN
#define TRIM_BITMAP_ALIGN (64)
#endif

#ifndef TB_NUM_SEGS
#define TB_NUM_SEGS ((UINT32)(((TOTAL_LPN_COUNT) + (TB_SEG_LPNS) - 1u) / (TB_SEG_LPNS)))
#endif

volatile UINT8* g_trim_bitmap     	= NULL; // LPN 비트맵
volatile UINT16* g_trim_seg_count	= NULL; // ★ 세그먼트 요약 플래그
volatile UINT32 g_trim_pending    	= 0;
volatile UINT32 g_trim_going    	= 0;

#define TRIM_SEG_BYTES      (TB_NUM_SEGS)
#define LPNS_PER_SEGMENT	(1024)
#define SEGMENT_COUNT       (TOTAL_LPN_COUNT / LPNS_PER_SEGMENT)

void TrimBitmap_Init(void)
{
    g_trim_bitmap = (volatile UINT8*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)TRIM_BITMAP_BYTES, /*align=*/64);
    DEBUG_ASSERT(g_trim_bitmap != NULL);
    OSAL_MEMSET((void*)g_trim_bitmap, 0, (UINT32)TRIM_BITMAP_BYTES);

    UINT32 count_array_size = SEGMENT_COUNT * sizeof(UINT16);
    g_trim_seg_count = (volatile UINT16*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)count_array_size, /*align=*/64);
    DEBUG_ASSERT(g_trim_seg_count != NULL);
    OSAL_MEMSET((void*)g_trim_seg_count, 0, count_array_size);
}

void SetTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        set_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    UINT32 head_end = seg_end_lpn(segS);
    set_range_same_segment(nStartLPN, head_end, segS);
    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0xFF, (size_t)seg_bytes);
        g_trim_seg_count[s] = LPNS_PER_SEGMENT;
    }

    UINT32 tail_begin = seg_base_lpn(segE);
    set_range_same_segment(tail_begin, nEndLPN, segE);
    TrimPending_Set();
}

void ClearTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        clear_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    UINT32 head_end = seg_end_lpn(segS);
    clear_range_same_segment(nStartLPN, head_end, segS);

    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0x00, (size_t)seg_bytes);
        g_trim_seg_count[s] = 0;
    }

    UINT32 tail_begin = seg_base_lpn(segE);
    clear_range_same_segment(tail_begin, nEndLPN, segE);
}

void CheckPendingTrim()
{
    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
    {
        if (g_trim_seg_count[i] > 0)
        {
            return;
        }
    }
    TrimPending_Clear();
}

#define INVALID_CID   (INVALID_VBN)

UINT32 FindTopKTrimSegments(UINT32 k)
{
	UINT32 Load_CNT = 0;
    if (k == 0) {
        return 0;
    }
    UINT16 anTopCounts[k];
    UINT32 anTopIndices[k];
    OSAL_MEMSET(anTopCounts, 0, sizeof(UINT16) * k);
    OSAL_MEMSET(anTopIndices, 0, sizeof(UINT32) * k);
    UINT16 nMinCountInTopK = 0;
    UINT32 nMinCountIdx = 0;

    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
    {
        UINT16 nCurrentCount = g_trim_seg_count[i];
        if (nCurrentCount <= 256) {
            continue;
        }
        if (nCurrentCount <= nMinCountInTopK) {
            continue;
        }
        anTopCounts[nMinCountIdx] = nCurrentCount;
        anTopIndices[nMinCountIdx] = i;
        nMinCountInTopK = anTopCounts[0];
        nMinCountIdx = 0;
        for (UINT32 j = 1; j < k; ++j) {
            if (anTopCounts[j] < nMinCountInTopK) {
                nMinCountInTopK = anTopCounts[j];
                nMinCountIdx = j;
            }
        }
    }
    UINT32 LOOP_CNT = 0;
    UINT32 loaded_cid    = INVALID_CID;  // 실제 LoadMeta가 발생한 첫 cluster ID 저장용

    for (UINT32 i = 0; i < k; ++i)
    {
        META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();

        UINT32 meta_base_lpn = anTopIndices[i] * 1024;
        loaded_cid = DFTL_GLOBAL::GetInstance()->GetClusterID(meta_base_lpn);

        UINT32 nMaxCount = anTopCounts[i];
        if (nMaxCount > 0)
        {
        	if (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE)
        		Load_CNT++;

            while (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE)
            {
            	LOOP_CNT += 1;
                pstMetaMgr->LoadMeta(meta_base_lpn, 1, 1);
                META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
                META_REQUEST* pstRequest;

                do {
                    REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                    pstReqMgr->_ProcessMetaRequestWaitQ();
                    FIL_Run();
                    pstRequest = pstMetaReqInfo->GetDoneRequest();
                    if (pstRequest != NULL) {
                        pstRequest->Run();
                    }
                } while (pstRequest != NULL);
            }
        }
    }
//    return Load_CNT;
    return loaded_cid;
}

UINT32 FindTopKTrimSegments(UINT32 k, UINT32 CID)
{
    if (k == 0u) return INVALID_CID;

    const UINT32 S     = (UINT32)SEGMENT_COUNT;
    const UINT32 SEG   = (UINT32)LPNS_PER_SEGMENT;
    const UINT32 k_eff = (k < S) ? k : S;

    // Top-K 버퍼: count / seg index / "CID 일치 여부"
    UINT16 topCnt[k_eff];
    UINT32 topIdx[k_eff];
    UINT8  topMatch[k_eff];   // 1: cid == CID, 0: 그 외

    OSAL_MEMSET(topCnt,   0, sizeof(topCnt));
    OSAL_MEMSET(topIdx,   0, sizeof(topIdx));
    OSAL_MEMSET(topMatch, 0, sizeof(topMatch));

    UINT32 filled = 0;

    // 현재 Top-K 중 "가장 나쁜(worst)" 후보 찾기
    // 우선순위 정의:
    //   1) topMatch (1이 더 좋음 → 0이 더 나쁨)
    //   2) 같은 topMatch 안에서 count 큰 게 좋으니, count 작은 게 더 나쁨
    //   3) 둘 다 같으면 seg index 큰 게 더 나쁨
    auto find_worst_idx = [&](UINT32 filled_) -> UINT32 {
        UINT32 w = 0;
        for (UINT32 j = 1; j < filled_; ++j) {
            if (topMatch[j] < topMatch[w]) {
                w = j;
            }
            else if (topMatch[j] == topMatch[w]) {
                if (topCnt[j] < topCnt[w]) {
                    w = j;
                }
                else if (topCnt[j] == topCnt[w]) {
                    if (topIdx[j] > topIdx[w]) {
                        w = j;
                    }
                }
            }
        }
        return w;
    };

    // 새 후보(seg)를 Top-K에 반영
    auto insert_candidate = [&](UINT16 cnt, UINT32 seg,
                                UINT8 isMatch, UINT32 &filled_) {
        if (cnt == 0u)    return;
        if (cnt < 256u)   return;   // 기존 정책 유지 (원하면 지워도 됨)

        if (filled_ < k_eff) {
            topCnt[filled_]   = cnt;
            topIdx[filled_]   = seg;
            topMatch[filled_] = isMatch;
            ++filled_;
        } else {
            UINT32 w = find_worst_idx(filled_);
            // "더 좋은" 후보인지 비교:
            //   1) isMatch(=CID 일치)가 더 크면 교체
            //   2) isMatch 동일하면 count가 더 크면 교체
            //   3) 둘 다 동일하면 seg index가 더 작으면 교체
            if ( (isMatch > topMatch[w]) ||
                 (isMatch == topMatch[w] && cnt > topCnt[w]) ||
                 (isMatch == topMatch[w] && cnt == topCnt[w] && seg < topIdx[w]) )
            {
                topCnt[w]   = cnt;
                topIdx[w]   = seg;
                topMatch[w] = isMatch;
            }
        }
    };

    // === 1패스: 모든 세그먼트를 훑으면서 Top-K 유지 ===
    for (UINT32 seg = 0; seg < S; ++seg) {
        UINT16 cnt = g_trim_seg_count[seg];
        if (cnt == 0u) continue;

        const UINT32 base_lpn = seg * SEG;
        const UINT32 tail_lpn = base_lpn + (SEG - 1u);

        const UINT32 cid_b = DFTL_GLOBAL::GetInstance()->GetClusterID(base_lpn);
        const UINT32 cid_t = DFTL_GLOBAL::GetInstance()->GetClusterID(tail_lpn);

        // "인자로 받은 CID와 일치하는 세그먼트" 정의:
        //   시작/끝 LPN 둘 중 하나라도 CID이면 match로 간주
        UINT8 isMatch = ( (cid_b == CID) || (cid_t == CID) ) ? 1u : 0u;

        insert_candidate(cnt, seg, isMatch, filled);
    }

    // === 2패스: 선정된 세그먼트들에 대해 메타 로딩 ===
    UINT32 Load_CNT   = 0;
    UINT32 LOOP_CNT   = 0;
    UINT32 loaded_cid = INVALID_CID;    // 실제로 Meta를 새로 로드한 첫 cluster ID

    DFTL_GLOBAL::GetInstance()->SB_PRINT_FLAG = TRUE;

    for (UINT32 i = 0; i < filled; ++i) {
        const UINT32 seg_idx  = topIdx[i];
        const UINT16 cnt      = topCnt[i];
        if (cnt == 0u) continue;    // 비어 있는 슬롯

        const UINT32 base_lpn = seg_idx * SEG;

        META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
        const UINT32 meta_base_lpn = base_lpn;

        if (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE) {
            ++Load_CNT;

            // 첫 번째로 실제 LoadMeta가 발생한 세그먼트의 CID를 기록
            if (loaded_cid == INVALID_CID) {
                loaded_cid = DFTL_GLOBAL::GetInstance()->GetClusterID(base_lpn);
            }
        }

        while (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE) {
            ++LOOP_CNT;
            pstMetaMgr->LoadMeta(meta_base_lpn, 1, 1);

            META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
            META_REQUEST* pstRequest;
            do {
                REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                pstReqMgr->_ProcessMetaRequestWaitQ();
                FIL_Run();
                pstRequest = pstMetaReqInfo->GetDoneRequest();
                if (pstRequest != NULL) {
                    pstRequest->Run();
                }
            } while (pstRequest != NULL);
        }
    }

    DFTL_GLOBAL::GetInstance()->SB_PRINT_FLAG = FALSE;

//    return Load_CNT;
    return loaded_cid;
}


#define INVALID_CID  (0xFFFFFFFFu)

UINT32 FindTopKTrimSegments_Pri(UINT32 k, UINT32 CID)
{
    if (k == 0u) return INVALID_CID;

    const UINT32 S     = (UINT32)SEGMENT_COUNT;
    const UINT32 SEG   = (UINT32)LPNS_PER_SEGMENT;
    const UINT32 k_eff = (k < S) ? k : S;

    // Top-K 버퍼
    UINT16 topCnt[k_eff];     // TRIM count
    UINT32 topIdx[k_eff];     // segment index
    UINT8  topMatch[k_eff];   // 1: cid == CID, 0: 그 외

    OSAL_MEMSET(topCnt,   0, sizeof(topCnt));
    OSAL_MEMSET(topIdx,   0, sizeof(topIdx));
    OSAL_MEMSET(topMatch, 0, sizeof(topMatch));

    UINT32 filled   = 0;      // 현재 Top-K에 채워진 개수
    UINT32 minPos   = 0;      // "가장 나쁜" 후보의 위치 (최소 cnt/우선순위)

    // 현재 topK에서 "가장 나쁜" 인덱스를 다시 계산
    auto recompute_min = [&](void) {
        UINT32 w = 0;
        for (UINT32 j = 1; j < filled; ++j) {
            // 우선순위가 낮은(= 더 나쁜) 조건:
            // 1) match(=cid==CID)가 작은게 더 나쁨
            if (topMatch[j] < topMatch[w]) {
                w = j;
            }
            // 2) match 같으면 cnt 작은게 더 나쁨
            else if (topMatch[j] == topMatch[w]) {
                if (topCnt[j] < topCnt[w]) {
                    w = j;
                }
                // 3) 둘 다 같으면 seg 인덱스 큰 게 더 나쁨
                else if (topCnt[j] == topCnt[w]) {
                    if (topIdx[j] > topIdx[w]) {
                        w = j;
                    }
                }
            }
        }
        minPos = w;
    };

    // === 1패스: 모든 세그먼트를 훑으면서 Top-K 유지 ===
    for (UINT32 seg = 0; seg < S; ++seg) {
        UINT16 cnt = g_trim_seg_count[seg];
        if (cnt == 0u)    continue;
        // 필요하면 threshold 사용 (없애도 됨)
        // if (cnt < 256u) continue;

        const UINT32 base_lpn = seg * SEG;
        const UINT32 tail_lpn = base_lpn + (SEG - 1u);

        const UINT32 cid_b = DFTL_GLOBAL::GetInstance()->GetClusterID(base_lpn);
        const UINT32 cid_t = DFTL_GLOBAL::GetInstance()->GetClusterID(tail_lpn);

        // "인자로 받은 CID와 관계" 표시: 시작/끝 중 하나라도 같으면 match=1
        UINT8 match = (cid_b == CID || cid_t == CID) ? 1u : 0u;

        if (filled < k_eff) {
            // 아직 버퍼가 안 찼으면 그대로 push
            topCnt[filled]   = cnt;
            topIdx[filled]   = seg;
            topMatch[filled] = match;
            ++filled;
            // 첫 K개 채워질 동안만 minPos를 재계산해 주면 됨
            recompute_min();
        } else {
            // 이미 K개 찬 상태 → "현재 제일 나쁜(minPos)"와 비교 후 필요하면 교체

            UINT16 curMinCnt   = topCnt[minPos];
            UINT8  curMinMatch = topMatch[minPos];
            UINT32 curMinIdx   = topIdx[minPos];

            bool better = false;

            // 우선순위 비교:
            // 1) match(=cid==CID) 가 더 큰 세그먼트가 더 좋음
            if (match > curMinMatch) {
                better = true;
            }
            // 2) match 같으면 cnt 큰 세그먼트가 더 좋음
            else if (match == curMinMatch && cnt > curMinCnt) {
                better = true;
            }
            // 3) match, cnt까지 같으면 seg 인덱스 작은 쪽이 더 좋음
            else if (match == curMinMatch && cnt == curMinCnt && seg < curMinIdx) {
                better = true;
            }

            if (better) {
                topCnt[minPos]   = cnt;
                topIdx[minPos]   = seg;
                topMatch[minPos] = match;
                // 교체했으니 가장 나쁜 위치 다시 찾아야 함
                recompute_min();
            }
        }
    }

    // === 2패스: 선택된 세그먼트들에 대해 메타 로딩 ===
    UINT32 Load_CNT   = 0;
    UINT32 LOOP_CNT   = 0;
    UINT32 loaded_cid = INVALID_CID;    // 실제로 새로 로드된 첫 cluster ID

    DFTL_GLOBAL::GetInstance()->SB_PRINT_FLAG = TRUE;

    for (UINT32 i = 0; i < filled; ++i) {
        const UINT32 seg_idx  = topIdx[i];
        const UINT16 cnt      = topCnt[i];
        if (cnt == 0u) continue;    // 빈 슬롯

        const UINT32 base_lpn = seg_idx * SEG;
        META_MGR* pstMetaMgr  = DFTL_GLOBAL::GetMetaMgr();
        const UINT32 meta_base_lpn = base_lpn;

        if (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE) {
            ++Load_CNT;
            // 첫 LoadMeta 대상의 CID를 리턴하고 싶으면 여기서 세팅
            if (loaded_cid == INVALID_CID) {
                loaded_cid = DFTL_GLOBAL::GetInstance()->GetClusterID(base_lpn);
            }
        }

        while (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE) {
            ++LOOP_CNT;
            pstMetaMgr->LoadMeta(meta_base_lpn, 1, 1);

            META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
            META_REQUEST* pstRequest;
            do {
                REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                pstReqMgr->_ProcessMetaRequestWaitQ();
                FIL_Run();
                pstRequest = pstMetaReqInfo->GetDoneRequest();
                if (pstRequest != NULL) {
                    pstRequest->Run();
                }
            } while (pstRequest != NULL);
        }
    }

    DFTL_GLOBAL::GetInstance()->SB_PRINT_FLAG = FALSE;

    // Load되지 않은 경우 INVALID_CID, 아니면 첫 Load 대상의 CID 리턴
//    return LOOP_CNT;
    return loaded_cid;
}



UINT32 FindTopKTrimSegments(UINT32 k, UINT32 min_CID, UINT32 vic_CID)
{
    if (k == 0u) return 0u;

    const UINT32 S     = (UINT32)SEGMENT_COUNT;
    const UINT32 SEG   = (UINT32)LPNS_PER_SEGMENT;
    const UINT32 k_eff = (k < S) ? k : S;

    // ----- 1) 두 CID 중 누가 1순위인지 결정 (겹치는 세그들의 count 총합 비교) -----
    auto seg_intersects_cid = [&](UINT32 seg, UINT32 CID) -> bool {
        const UINT32 base_lpn = seg * SEG;
        const UINT32 tail_lpn = base_lpn + (SEG - 1u);
        const UINT32 cid_b    = DFTL_GLOBAL::GetInstance()->GetClusterID(base_lpn);
        const UINT32 cid_t    = DFTL_GLOBAL::GetInstance()->GetClusterID(tail_lpn);
        return (cid_b == CID) || (cid_t == CID);
    };

    auto seg_full_in_cid = [&](UINT32 seg, UINT32 CID) -> bool {
        const UINT32 base_lpn = seg * SEG;
        const UINT32 tail_lpn = base_lpn + (SEG - 1u);
        const UINT32 cid_b    = DFTL_GLOBAL::GetInstance()->GetClusterID(base_lpn);
        const UINT32 cid_t    = DFTL_GLOBAL::GetInstance()->GetClusterID(tail_lpn);
        return (cid_b == CID) && (cid_t == CID);
    };

    UINT32 cidA = min_CID, cidB = vic_CID;
    bool same = (cidA == cidB);

    UINT64 sumA = 0, sumB = 0;
    if (!same) {
        for (UINT32 seg = 0; seg < S; ++seg) {
            UINT16 cnt = g_trim_seg_count[seg];
            if (cnt < 256) continue;
            if (seg_intersects_cid(seg, cidA)) sumA += cnt;
            if (seg_intersects_cid(seg, cidB)) sumB += cnt;
        }
    }

    UINT32 primaryCID   = cidA;
    UINT32 secondaryCID = same ? (UINT32)(~0u) : cidB;
    if (!same && sumB > sumA) { primaryCID = cidB; secondaryCID = cidA; }

    UINT16 pFullCnt[k_eff], pPartCnt[k_eff], sFullCnt[k_eff], sPartCnt[k_eff], gCnt[k_eff];
    UINT32 pFullIdx[k_eff], pPartIdx[k_eff], sFullIdx[k_eff], sPartIdx[k_eff], gIdx[k_eff];
    OSAL_MEMSET(pFullCnt, 0, sizeof(pFullCnt));
    OSAL_MEMSET(pPartCnt, 0, sizeof(pPartCnt));
    OSAL_MEMSET(sFullCnt, 0, sizeof(sFullCnt));
    OSAL_MEMSET(sPartCnt, 0, sizeof(sPartCnt));
    OSAL_MEMSET(gCnt,     0, sizeof(gCnt));
    OSAL_MEMSET(pFullIdx, 0, sizeof(pFullIdx));
    OSAL_MEMSET(pPartIdx, 0, sizeof(pPartIdx));
    OSAL_MEMSET(sFullIdx, 0, sizeof(sFullIdx));
    OSAL_MEMSET(sPartIdx, 0, sizeof(sPartIdx));
    OSAL_MEMSET(gIdx,     0, sizeof(gIdx));

    UINT32 fillPF = 0, fillPP = 0, fillSF = 0, fillSP = 0, fillG = 0;

    auto find_worst_idx = [&](UINT16 *cntArr, UINT32 *idxArr, UINT32 filled) -> UINT32 {
        UINT32 w = 0;
        for (UINT32 j = 1; j < filled; ++j) {
            if (cntArr[j] < cntArr[w]) w = j;
            else if (cntArr[j] == cntArr[w] && idxArr[j] > idxArr[w]) w = j;
        }
        return w;
    };

    auto insert_bucket = [&](UINT16 *cntArr, UINT32 *idxArr, UINT32 &filled,
                             UINT16 cnt, UINT32 seg) {
        if (cnt < 256) return; // 임계값 필터 (후보/로딩 모두 동일)
        if (filled < k_eff) {
            cntArr[filled] = cnt; idxArr[filled] = seg; ++filled;
        } else {
            UINT32 w = find_worst_idx(cntArr, idxArr, filled);
            if ((cnt > cntArr[w]) || (cnt == cntArr[w] && seg < idxArr[w])) {
                cntArr[w] = cnt; idxArr[w] = seg;
            }
        }
    };

    // ----- 3) 1패스 스캔: 각 세그를 최적 버킷에 투입 -----
    for (UINT32 seg = 0; seg < S; ++seg) {
        UINT16 cnt = g_trim_seg_count[seg];
        if (cnt < 256) continue;

        bool inP    = seg_intersects_cid(seg, primaryCID);
        bool fullP  = inP && seg_full_in_cid(seg, primaryCID);
        bool inS    = (!same && secondaryCID != (UINT32)(~0u)) ? seg_intersects_cid(seg, secondaryCID) : false;
        bool fullS  = inS && seg_full_in_cid(seg, secondaryCID);

        if (inP) {
            if (fullP) insert_bucket(pFullCnt, pFullIdx, fillPF, cnt, seg);
            else       insert_bucket(pPartCnt, pPartIdx, fillPP, cnt, seg);
        } else if (inS) {
            if (fullS) insert_bucket(sFullCnt, sFullIdx, fillSF, cnt, seg);
            else       insert_bucket(sPartCnt, sPartIdx, fillSP, cnt, seg);
        } else {
            insert_bucket(gCnt, gIdx, fillG, cnt, seg);
        }
    }

    // ----- 4) 버킷 정렬 (count 내림차순, seg idx 오름차순) -----
    auto sort_bucket = [&](UINT16 *cntArr, UINT32 *idxArr, UINT32 filled) {
        for (UINT32 i = 0; i + 1 < filled; ++i) {
            UINT32 best = i;
            for (UINT32 j = i + 1; j < filled; ++j) {
                if (cntArr[j] > cntArr[best] ||
                    (cntArr[j] == cntArr[best] && idxArr[j] < idxArr[best])) {
                    best = j;
                }
            }
            if (best != i) {
                UINT16 tc = cntArr[i]; cntArr[i] = cntArr[best]; cntArr[best] = tc;
                UINT32 ti = idxArr[i]; idxArr[i] = idxArr[best]; idxArr[best] = ti;
            }
        }
    };

    sort_bucket(pFullCnt, pFullIdx, fillPF);
    sort_bucket(pPartCnt, pPartIdx, fillPP);
    sort_bucket(sFullCnt, sFullIdx, fillSF);
    sort_bucket(sPartCnt, sPartIdx, fillSP);
    sort_bucket(gCnt,     gIdx,     fillG);

    // ----- 5) 최종 선택: P_FULL → P_PART → S_FULL → S_PART → GLOBAL -----
    UINT32 selIdx[k_eff]; UINT16 selCnt[k_eff]; UINT32 sel_n = 0;
    auto drain = [&](UINT16 *cntArr, UINT32 *idxArr, UINT32 &filled) {
        for (UINT32 i = 0; i < filled && sel_n < k_eff; ++i) {
            selCnt[sel_n] = cntArr[i]; selIdx[sel_n] = idxArr[i]; ++sel_n;
        }
    };

    drain(pFullCnt, pFullIdx, fillPF);
    if (sel_n < k_eff) drain(pPartCnt, pPartIdx, fillPP);
    if (sel_n < k_eff) drain(sFullCnt, sFullIdx, fillSF);
    if (sel_n < k_eff) drain(sPartCnt, sPartIdx, fillSP);
    if (sel_n < k_eff) drain(gCnt,     gIdx,     fillG);

    // ----- 6) 메타 로딩: selIdx[0..sel_n) 만 (cnt >= 256 보장) -----
    UINT32 Load_CNT = 0;
    UINT32 LOOP_CNT = 0;

    for (UINT32 i = 0; i < sel_n; ++i) {
        const UINT32 seg_idx  = selIdx[i];
        const UINT32 base_lpn = seg_idx * SEG;

        META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
        if (pstMetaMgr->IsMetaAvailable(base_lpn, 0) == FALSE)
            ++Load_CNT;

        while (pstMetaMgr->IsMetaAvailable(base_lpn, 0) == FALSE) {
            ++LOOP_CNT;
            pstMetaMgr->LoadMeta(base_lpn, 1, 1);

            META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
            META_REQUEST* pstRequest;
            do {
                REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                pstReqMgr->_ProcessMetaRequestWaitQ();
                FIL_Run();
                pstRequest = pstMetaReqInfo->GetDoneRequest();
                if (pstRequest != NULL) {
                    pstRequest->Run();
                }
            } while (pstRequest != NULL);
        }
    }

    return Load_CNT;
}

VIRTUAL BOOL
DFTL_GLOBAL::Format(VOID)
{
	BOOL	bRet;

	GetUserBlockMgr()->Format();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Format();
	bRet = GetMetaL2VMgr()->Format();
#endif

	bRet = GetMetaMgr()->Format();			// THIS MUST BE AT THE END OF FORMAT ROUTINE

	return bRet;
}

VIRTUAL VOID 
DFTL_GLOBAL::Run(VOID)
{
	FIL_Run();
	GetRequestMgr()->Run();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->CheckAndStartGC();
		}
	}
#endif
	if (GetSuperGCMgr()->CheckAndStartGC())
	{
		for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
			for (UINT32 way = 0; way < USER_WAYS; way++) {
				GetGCMgr(channel, way)->CheckAndStartGC();
			}
		}
	}

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->Run();
		}
	}
#endif
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetGCMgr(channel, way)->Run();
		}
	}
}

/*
	@brief	Add HIL read request to waitQ
*/
VIRTUAL VOID
DFTL_GLOBAL::ReadPage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;

	if (nLPN == 77)
	{
		if ((nCount == 77) || (nCount == 78))
			DFTL_PrintProfile(0);
		else
			DFTL_PrintProfile(1);
		m_bEnable += 1;
	}

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_READ_WAIT, NVME_CMD_OPCODE_READ, 
						nLPN, nCmdSlotTag, nCount);
#ifndef WIN32
	//xil_printf("1	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_read, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::WritePage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;
	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_WRITE_WAIT, NVME_CMD_OPCODE_WRITE, 
		nLPN, nCmdSlotTag, nCount);

//	if (m_bEnable > 1)
//		xil_printf("WRITE REQ INIT [LPN:%u, Length:%u]\r\n", nLPN, nCount);

#ifndef WIN32
	//xil_printf("7	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_write, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::DatasetManagement(UINT32 nCmdSlotTag, UINT32 nr, UINT32 ad)
{
	HIL_REQUEST*	pstRequest;

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_DSM_WAIT, NVME_CMD_OPCODE_DSM,
		ad, nCmdSlotTag, nr);

	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_Discard);
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::CallBack(FTL_REQUEST_ID stReqID)
{
#if (UNIT_TEST_FIL_PERF == 1)
	return;
#endif

	switch (stReqID.stCommon.nType)
	{
	case FTL_REQUEST_ID_TYPE_HIL_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		HIL_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetHILRequestInfo();
		HIL_REQUEST_PER_WAY * pstRequest = pstRequestInfo->GetRequest_per_way(stReqID.stHIL.nRequestIndex);

		pstRequest->IncreaseDoneCount();
		pstRequest->pBufEntry[stReqID.stHIL.bufOffset]->readDone = 1;

		if (pstRequest->GetDoneCount() == pstRequest->GetLPNCount())
		{
			// all read done  
			// remove from issued Q
			pstRequestInfo->RemoveFromIssuedQ_per_way(pstRequest);

			pstRequest->HDMAIssue();

			// add to done Q
			pstRequestInfo->AddToDoneQ_per_way(pstRequest);		// wait for HDMA Issue

			pstRequest->GoToNextStatus();		// NAND Issued -> NAND_DONE
		}

		break;
	}
	case FTL_REQUEST_ID_TYPE_WRITE:
	{
		// Pysical page program done
		INT32	nIndex = stReqID.stProgram.nActiveBlockIndex;
		IOTYPE	eIOType = static_cast<IOTYPE>(stReqID.stProgram.nIOType);

		ACTIVE_BLOCK* pstActiveBlock = DFTL_GLOBAL::GetActiveBlockMgr(stReqID.cluster, stReqID.channel, stReqID.way)->GetActiveBlock(nIndex, eIOType);
		pstActiveBlock->ProgramDone(stReqID.stProgram.nBufferingIndex);
		break;
	}
	case FTL_REQUEST_ID_TYPE_GC_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		GC_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetGCRequestInfo();
		GC_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stGC.nRequestIndex);
		pstRequest->GCReadDone();
		break;
	}
#if (SUPPORT_META_DEMAND_LOADING == 1)
	case FTL_REQUEST_ID_TYPE_META_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
		META_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stMeta.nRequestIndex);

		pstRequestInfo->RemoveFromIssuedQ(pstRequest);
		pstRequestInfo->AddToDoneQ(pstRequest);
		pstRequest->GoToNextStatus();					// NAND Issued -> NAND_DONE

		break;
	}
#endif
	default:
		ASSERT(0);
		break;
	}
}

VIRTUAL VOID 
DFTL_GLOBAL::IOCtl(IOCTL_TYPE eType)
{
	switch (eType)
	{
	case IOCTL_INIT_PROFILE_COUNT:
		m_stProfile.Initialize();
		break;

	case IOCTL_PRINT_PROFILE_COUNT:
		m_stProfile.Print();
		break;

	default:
		ASSERT(0);		// unknown type
		break;
	}

	return;
}

VOID
DFTL_GLOBAL::SetStatus(DFTL_STATUS eStatus)
{
	m_eStatus = static_cast<DFTL_STATUS>(m_eStatus | eStatus);
}

BOOL
DFTL_GLOBAL::CheckStatus(DFTL_STATUS eStatus)
{
	return (m_eStatus & eStatus) ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	static function
//

VOID 
DFTL_GLOBAL::_Initialize(VOID)
{
	UINT32 nPPagesPerVBlock = m_stVNand.GetPPagesPerVBlock();
	m_nPhysicalFlashSizeKB = USER_CHANNELS * USER_WAYS * m_stVNand.GetVBlockCount() * nPPagesPerVBlock * (PHYSICAL_PAGE_SIZE / KB);

	m_nVBlockSizeKB			= nPPagesPerVBlock * PHYSICAL_PAGE_SIZE;
	m_nVPagesPerVBlock		= m_stVNand.GetVPagesPerVBlock();
	m_nLPagesPerVBlockBits	= UTIL_GetBitCount(m_nVPagesPerVBlock);
	m_nLPagesPerVBlockMask	= (1 << m_nLPagesPerVBlockBits) - 1;

	m_fOverProvisionRatio = (float)OVERPROVISION_RATIO_DEFAULT;
	m_nOverprovisionSizeKB = (INT64)(m_nPhysicalFlashSizeKB * m_fOverProvisionRatio);
	m_nLogicalFlashSizeKB = m_nPhysicalFlashSizeKB - m_nOverprovisionSizeKB;

#if (SUPPORT_STATIC_DENSITY != 0)
	UINT32 nLogicalFlashSizeKB = SUPPORT_STATIC_DENSITY * (GB / KB);

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);

	m_nLogicalFlashSizeKB = nLogicalFlashSizeKB;		// update logical flash size

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);
#endif

	m_nLPNCount			= m_nLogicalFlashSizeKB / LOGICAL_PAGE_SIZE_KB;

	m_nVBlockCount		= m_stVNand.GetVBlockCount();

#if (SUPPORT_META_BLOCK == 1)
	m_bEnableMetaBlock = TRUE;
#else
	m_bEnableMetaBlock = FALSE;
#endif

	m_nGCTh = FREE_BLOCK_GC_THRESHOLD_DEFAULT;

	HIL_SetStorageBlocks(m_nLPNCount);

	m_stProfile.Initialize();
}

VOID 
DFTL_GLOBAL::_PrintInfo(VOID)
{
#if defined(FPM_FTL)
	char	psFTL[] = "FPMFTL";
#elif defined(DFTL)
	char	psFTL[] = "DFTL";
#else
#error check config
#endif

	PRINTF("[%s] Physical Density: %d MB \n\r", psFTL, m_nPhysicalFlashSizeKB / KB);
	PRINTF("[%s] Logical Density: %d MB \n\r", psFTL, m_nLogicalFlashSizeKB / KB);
}

VOID SBINFO_MGR::Initialize()
{
	INT32 nSize = sizeof(SBINFO) * DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();
	m_pastSBInfo = (SBINFO *)OSAL_MemAlloc(MEM_TYPE_FW_DATA, nSize, OSAL_MEMALLOC_FW_ALIGNMENT);
	m_nFreeCount = 0;

	int c = DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();
	for (int i=0; i<c; i++)
	{
		m_pastSBInfo[i].SetFree();
		m_pastSBInfo[i].m_nVBN = i;
		m_pastSBInfo[i].m_nUSED = 0;
		m_pastSBInfo[i].m_bBad = 0;
		m_pastSBInfo[i].m_bCID = USER_CLUSTERS;
		if (i<20)
		{
//			xil_printf("SBINFO META INIT %d\r\n", i);
			m_pastSBInfo[i].m_bMeta = 1;
		}
		else
		{
//			xil_printf("SBINFO HOST INIT %d\r\n", i);
			m_pastSBInfo[i].m_bMeta = 0;
		}
	}
}

VOID Read_Cache::Initialize()
{
	for (int i = 0; i < MAX_READ_CACHE_ENTRY; i++)
	{
		source_lpn[i] = 0xffffffff;
		nVPPN[i] = 0xffffffff;
		Buf[i] = DFTL_GLOBAL::GetBufferMgr()->Allocate();
		if (Buf[i] == NULL)
			ASSERT(0);
		Buf[i]->readDone = 1;
	}

	return VOID();
}

BUFFER_ENTRY * Read_Cache::change_next_buffer(UINT32 src_lpn, BUFFER_ENTRY * input_buf, UINT32 channel, UINT32 way)
{
	BUFFER_ENTRY * ret;

	UINT32 iter;
//	UINT32 channel, way;
//	channel = get_channel_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
//	way = get_way_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;

	for (iter = start_offset; iter < end_offset; iter++)
	{
		if (Buf[iter]->refCount == 0)
		{
			break;
		}
	}
	if (iter == end_offset)
		return NULL;

	ret = Buf[iter];
	source_lpn[iter] = src_lpn;
	Buf[iter] = input_buf;
	nVPPN[iter] = input_buf->nVPPN >> NUM_BIT_LPN_PER_PAGE;
	return ret;
}


BUFFER_ENTRY * Read_Cache::get_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
			return Buf[iter];
	}
	return NULL;
}

VOID Read_Cache::free_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
		{
			Buf[iter]->nVPPN = 0xffffffff;
			nVPPN[iter] = 0xffffffff;
			return;
		}
	}
}
