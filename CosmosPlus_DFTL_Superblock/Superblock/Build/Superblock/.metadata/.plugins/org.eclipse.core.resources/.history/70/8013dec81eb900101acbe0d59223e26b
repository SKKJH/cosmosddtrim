/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/
#include "assert.h"
#include "xil_types.h"
#include "debug.h"

#include "cosmos_plus_system.h"
#include "cosmos_plus_memory_map.h"

#ifdef GREEDY_FTL
#include "request_schedule.h"
#endif

#include "cosmos_plus_system.h"

#include "fil.h"
#include "fil_nand.h"
#include "../Target/osal.h"
#include "fil_request.h"

static void _AddToWaitQ(FTL_REQUEST_TYPE nReqType, FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf);
static BOOL anBadPBN[USER_CHANNELS][USER_WAYS][TOTAL_BLOCKS_PER_DIE / 8];

void set_badPBN(UINT32 channel, UINT32 way, UINT32 pblk)
{
	UINT32 offset = pblk >> 3;
	UINT32 offset_in_byte = pblk % 8;

	anBadPBN[channel][way][offset] |= 1 << offset_in_byte;

}
void FIL_Initialize(void)
{
	NAND_Initialize();
	FIL_InitRequest();
	memset(&anBadPBN[0][0][0], 0, USER_CHANNELS * USER_WAYS * TOTAL_BLOCKS_PER_DIE / 8);
	/*set_badPBN(1, 1, 256);
	set_badPBN(1, 1, 320);
	set_badPBN(1, 1, 330);


	set_badPBN(2, 3, 415);
	set_badPBN(2, 3, 481);
	set_badPBN(2, 3, 505);
	set_badPBN(2, 3, 565);
	set_badPBN(2, 3, 585);

	set_badPBN(3, 3, 517);
	set_badPBN(3, 3, 527);
	set_badPBN(3, 3, 579);*/

#ifndef WIN32
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++)
		{

		}
	}
#endif
}

void FIL_Run(void)
{
	if (FIL_IsIdle() == TRUE)
	{
		return;
	}

	// not implemented yet!
	FIL_ProcessDoneQ();
	FIL_ProcessIssuedQ();
	FIL_ProcessWaitQ();
}

/*
	@brief check a block is bad or not.
			channel and way does not considered in current implementation.
			the reason is FTL uses VBlock, which is super block.
*/
BOOL FIL_IsBad(INT32 channel, INT32 way, INT32 nPBN)
{
	// Bad block of cosmos+
	static int anBadPBN2[] =
	{
		2300, 2312, 2327, 2336, 2368, 2379, 2386, 2399,
		2135, 2136, 2138, 2147, 2162, 2172, 2255, 2259, 2270, 2271, 2275, 2283, 2285,
		1920, 1927, 1937, 1964, 1990, 2008, 2009, 2037, 2051, 2095, 2111, 2113,
		1728, 1739, 1747, 1765, 1790, 1798, 1814, 1841, 1859, 1881, 1895,
		1626, 1629, 1650, 1663, 1685, 1695, 1704, 1708, 1711, 1715,
		1332, 1344, 1348, 1355, 1380, 1388, 1391, 1395, 1481, 1529, 1539, 1566, 1613, 1625, 1990,
		1161, 1204, 1205, 1209, 1211, 1225, 1231, 1241, 1242, 1277, 1283, 1311,
		424, 429, 521, 543, 594, 629, 640, 909, 1095, 1098, 1101, 1113,
		928, 566, 564, 562, 256, 320, 330, 415, 481, 505, 517, 527 ,565, 579, 585, 685, 699,
		712, 714, 723, 735, 770, 776, 777, 801, 811, 818, 844 ,849, 886, 919, 927, 935, 949,
		952, 974, 983, 997, 1017, 1019, 1033, 1049, 1054, 1064, 1099, 1147, 1157, 1183, 1190,
		1195, 1232, 1250, 1263, 1287, 1330, 1334, 13335, 1343, 1354, 1357, 1363, 1370, 1374,
		1386, 1400, 1407, 1423, 1443, 1457, 1540, 1569, 1580, 1596, 1597, 1602, 1614, 1651,
		1658, 1659, 1664, 1670, 1674, 1675, 1679, 1694, 1710, 1714, 1754, 1762, 1813, 1815,
		1822, 1828, 1842, 1845, 1852, 1862, 1897, 1899, 1925, 1933, 1936, 1946, 1950, 1991,
		2027, 2032, 2038, 2047, 2060, 2072, 2080, 2094, 2116, 2120, 2121, 2123, 2169, 2177, 2185,
		2187, 2203, 2209, 2212, 2211, 2221, 2229, 2238, 2265, 2307, 2309, 2314, 2319, 2350, 2359, 2384,
		2388, 2389, 2397, 849, 1263, 2094, 1263, 2094, 949, 1330, 1580, 1670, 935, 1064, 1549, 1259,
		1335, 1206, 1221, 1223, 1229, 1255, 1257, 1273, 1310, 1316, 1317, 1319, 1336, 1358, 1364,
		1369, 1389, 1394, 1424, 1449, 1453, 1455, 1467, 1482, 1489, 1500, 1501, 1532, 1534, 1552,
		1565, 1590, 1608, 1610, 1638, 1642, 1666, 1698, 1702, 1752, 1768, 1776, 1795, 1810, 1820,
		1824, 1824, 1848, 1856, 1866, 1870, 1880, 1885, 1892, 1894, 1900, 1902, 1926, 1940, 1942, 1961,
		1972, 1996, 2004, 2012, 2029, 2035, 2054, 2058, 2067, 2077, 2086, 2110, 2114, 2118, 2152,
		2155, 2164, 2173, 2179, 1825, 2220, 2405, 2407, 2408, 2438, 2446, 2455, 2456, 2457, 2459, 2468,
		2484, 2491, 2490, 2500, 2509, 2532, 2535, 2540, 2543, 2551, 2550, 2557, 2600, 2603, 2604, 2616, 2617,
	};
	for (int i = 0; i < sizeof(anBadPBN2) / sizeof(int); i++)
	{
		if (anBadPBN2[i] == nPBN)
		{
			break;
		}
	}

	UINT32 offset = nPBN >> 3;
	UINT32 offset_in_byte = nPBN % 8;
	if (anBadPBN[channel][way][offset] & (1 << offset_in_byte))
	{
		return TRUE;
	}
	

	return FALSE;
}

BOOL FIL_IsEmpty_way(INT32 channel, INT32 way)
{
	return _FIL_IsEmptyWay(channel, way);
}

/*
	@brief	COSMOS+ does not support partial page read 
*/
void FIL_ReadPage(FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
{
#ifdef SUPPORT_DATA_VERIFICATION
	#ifdef WIN32
		OSAL_MEMSET(pMainBuf, 0xFF, (sizeof(INT32) * 4/*LPN_PER_PHYSICAL_PAGE*/));
	#endif
		OSAL_MEMSET(pSpareBuf, 0xFF, (sizeof(INT32) * 4 /*LPN_PER_PHYSICAL_PAGE*/));
#endif
	
	_AddToWaitQ(FTL_REQUEST_READ, stReqID, stPhyAddr, pMainBuf, pSpareBuf);
}

void FIL_ProgramPage(FTL_REQUEST_ID	stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
{
	_AddToWaitQ(FTL_REQUEST_PROGRAM, stReqID, stPhyAddr, pMainBuf, pSpareBuf);
}

void FIL_EraseBlock(FTL_REQUEST_ID	stReqID, NAND_ADDR stPhyAddr)
{
	_AddToWaitQ(FTL_REQUEST_ERASE, stReqID, stPhyAddr, NULL, NULL);
}

int FIL_GetPagesPerBlock(void)
{
	int nPagesPerBlock;

	if (BITS_PER_CELL == 1)
	{
		nPagesPerBlock = PAGES_PER_SLC_BLOCK;
	}
	else if (BITS_PER_CELL == 2)
	{
		nPagesPerBlock = PAGES_PER_MLC_BLOCK;
	}
	else
	{
		ASSERT(0);	// not supported
		nPagesPerBlock = 0;
	}

	return nPagesPerBlock;
}

static void _AddToWaitQ(FTL_REQUEST_TYPE nReqType, FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
{
#if defined(_DEBUG) && defined(STREAM_FTL)
	DEBUG_ASSERT(stReqID.stCommon.nType < FTL_REQUEST_ID_TYPE_COUNT);
	switch (stReqID.stCommon.nType)
	{
		case FTL_REQUEST_ID_TYPE_PROGRAM:
			// In this context FIL does not know what sub-type of write, (sub type must be one of HIL Write, GC Write, StreamMerge Write)
			break;

		case FTL_REQUEST_ID_TYPE_HIL_READ:
		case FTL_REQUEST_ID_TYPE_STREAM_MERGE_READ:
		case FTL_REQUEST_ID_TYPE_BLOCK_GC_READ:
			break;

		default:
			ASSERT(0);		// Invalid type for NAND IO
			break;
	}

	DEBUG_ASSERT(pMainBuf);
	DEBUG_ASSERT(pSpareBuf);
#endif

	// Allocate Request
	FTL_REQUEST*	pstRequest;
	pstRequest = FIL_AllocateRequest();

	DEBUG_ASSERT(pstRequest->nStatus == FTL_REQUEST_FREE);

	pstRequest->stRequestID = stReqID;
	pstRequest->nType = nReqType;
	pstRequest->stAddr = stPhyAddr;
	pstRequest->stBuf.pMainBuf = pMainBuf;
	pstRequest->stBuf.pSpareBuf = pSpareBuf;

	switch (nReqType)
	{
	case FTL_REQUEST_READ:
		pstRequest->nStatus = FTL_REQUEST_READ_WAIT;
		break;

	case FTL_REQUEST_PROGRAM:
		if (stPhyAddr.nPPage == 0)
		{
			pstRequest->nStatus = FTL_REQUEST_ERASE_FOR_PROGRAM_WAIT;
		}
		else
		{
			pstRequest->nStatus = FTL_REQUEST_PROGRAM_WAIT;
		}
		break;

	case FTL_REQUEST_ERASE:
		pstRequest->nStatus = FTL_REQUEST_ERASE_WAIT;
		break;
	}

	// Add to waitQ
	FIL_AddToRequestWaitQ(pstRequest, FALSE);

}
