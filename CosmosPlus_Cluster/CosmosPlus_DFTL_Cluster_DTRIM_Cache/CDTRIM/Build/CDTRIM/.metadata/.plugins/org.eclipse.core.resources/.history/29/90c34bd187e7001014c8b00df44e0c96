/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "dftl_internal.h"

///////////////////////////////////////////////////////////////////////////////
//
//	META REQUEST
//
///////////////////////////////////////////////////////////////////////////////

#ifndef TRIM_BITMAP_BYTES
#define TRIM_BITMAP_BYTES  ((TOTAL_LPN_COUNT + 7u) >> 3)
#endif

static inline void _safe_store_u32(UINT32* p, UINT32 v) {
    uintptr_t a = (uintptr_t)p;
    if ((a & 3u) == 0) { *p = v; }
    else {
        volatile UINT8* b = (volatile UINT8*)p;
        b[0] = (UINT8)(v      );
        b[1] = (UINT8)(v >>  8);
        b[2] = (UINT8)(v >> 16);
        b[3] = (UINT8)(v >> 24);
    }
}

BOOL META_MGR::ApplyTrimIfCached(UINT32 nLPN)
{
    META_CACHE_ENTRY* pEntry = m_stMetaCache.GetMetaEntry(nLPN, META_OPT);

    if (pEntry != NULL)
    {
        ApplyTrimOnLoadedEntry_OPT(pEntry, pEntry->m_nMetaLPN);
        return TRUE; // 처리됨
    }

    return FALSE; // 캐시에 없음 (Miss)
}

//VOID
//META_MGR::ApplyTrimOnLoadedEntry_OPT(META_CACHE_ENTRY* pEntry, UINT32 metaLPN)
//{
//	UINT32 TRIM_CNT = 0;
//
//    VNAND* v = DFTL_GLOBAL::GetVNandMgr();
//    BLOCK_MGR* ubm = DFTL_GLOBAL::GetInstance()->GetUserBlockMgr();
//
//    DEBUG_ASSERT(pEntry != NULL);
//    DEBUG_ASSERT(pEntry->m_bValid == TRUE);
//
//    const UINT32 start_lpn = metaLPN * L2V_PER_META_PAGE;
//    const UINT32 end_lpn   = start_lpn + L2V_PER_META_PAGE - 1;
//
//    UINT32 byte_start  = (start_lpn >> 3);
//    UINT32 byte_end_ex = (end_lpn   >> 3) + 1;   // exclusive
//
//    if (byte_start >= TRIM_BITMAP_BYTES) {
//        ClearTrimRange(start_lpn, end_lpn);
//        return;
//    }
//    if (byte_end_ex > TRIM_BITMAP_BYTES) byte_end_ex = TRIM_BITMAP_BYTES;
//
//    UINT32 old_vppns[L2V_PER_META_PAGE];
//    UINT32 inv_cnt = 0;
//
//    bool touched = false;
//
//    for (UINT32 b = byte_start; b < byte_end_ex; ++b) {
//        UINT8 bits = g_trim_bitmap[b];
//        if (!bits) continue;
//
//        const UINT32 lpn_base = (b << 3);
//        const UINT32 i_base   = lpn_base - start_lpn;
//        const UINT32 bit_lo = (b == byte_start)        ? (start_lpn & 7) : 0;
//        const UINT32 bit_hi = (b == (byte_end_ex - 1)) ? (end_lpn   & 7) : 7;
//
//        UINT8 range_mask = (UINT8)((0xFFu << bit_lo) & (0xFFu >> (7u - bit_hi)));
//        UINT8 work = (UINT8)(bits & range_mask);
//        if (!work) continue;
//
//        for (UINT32 bit = bit_lo; bit <= bit_hi; ++bit) {
//        	UINT8 m = (UINT8)(1u << bit);
//            if (!(work & m)) continue;
//
//            UINT32 i   = i_base + bit;
//            if (i >= (UINT32)L2V_PER_META_PAGE) continue;
//
//            UINT32 oldVPPN = pEntry->m_anL2V[i];
//            if (oldVPPN == INVALID_PPN) continue;
//            if ((v->GetV2L(oldVPPN))!= (start_lpn + i)) continue;
//
//            UINT32 nVBN = VBN_FROM_VPPN(oldVPPN);
//            UINT32 channel = CHANNEL_FROM_VPPN(oldVPPN);
//            UINT32 way = WAY_FROM_VPPN(oldVPPN);
//
//            VBINFO*		pstVBInfo;
//            pstVBInfo = DFTL_GLOBAL::GetVBInfoMgr(channel, way)->GetVBInfo(nVBN);
//            if (pstVBInfo->IsActive()) continue;
//            if (DFTL_GLOBAL::GetGCMgr(channel, way)->return_VBN() == nVBN) continue;
//
//            UINT32 nLPN = start_lpn + i;
//            UINT32 cID  = DFTL_GLOBAL::GetInstance()->GetClusterID(nLPN);
//            DFTL_GLOBAL::GetInstance()->m_util_pages[cID] -= 1;
//
//            _safe_store_u32(&pEntry->m_anL2V[i], INVALID_PPN);
//            touched = true;
//
//            if (inv_cnt < (UINT32)L2V_PER_META_PAGE) {
//                old_vppns[inv_cnt] = oldVPPN;
//                ++inv_cnt;
//                TRIM_CNT += 1;
//            }
//        }
//    }
//    if (touched) pEntry->m_bDirty = TRUE;
//
//    if (inv_cnt) {
//        for (UINT32 k = 0; k < inv_cnt; ++k) {
//            v->Invalidate(old_vppns[k], 1);
//            ubm->Invalidate(old_vppns[k]);
//			DFTL_IncreaseProfile(Prof_Discard_CMT_Num);
//        }
//    }
//    ClearTrimRange(start_lpn, end_lpn);
//}

VOID META_MGR::ApplyTrimOnLoadedEntry_OPT(META_CACHE_ENTRY* pEntry, UINT32 metaLPN)  //0102
{
    UINT32 TRIM_CNT = 0;
    VNAND* v = DFTL_GLOBAL::GetVNandMgr();
    BLOCK_MGR* ubm = DFTL_GLOBAL::GetInstance()->GetUserBlockMgr();

    DEBUG_ASSERT(pEntry != NULL);
    DEBUG_ASSERT(pEntry->m_bValid == TRUE);

    const UINT32 start_lpn = metaLPN * L2V_PER_META_PAGE;
    const UINT32 end_lpn   = start_lpn + L2V_PER_META_PAGE - 1;

    UINT32 byte_start  = (start_lpn >> 3);
    UINT32 byte_end_ex = (end_lpn   >> 3) + 1;

    if (byte_start >= TRIM_BITMAP_BYTES) {
        ClearTrimRange(start_lpn, end_lpn);
        return;
    }
    if (byte_end_ex > TRIM_BITMAP_BYTES) byte_end_ex = TRIM_BITMAP_BYTES;

    UINT32 old_vppns[L2V_PER_META_PAGE];
    UINT32 inv_cnt = 0;
    bool touched = false;

    for (UINT32 b = byte_start; b < byte_end_ex; ++b) {
        UINT8 bits = g_trim_bitmap[b];
        if (!bits) continue;

        const UINT32 lpn_base = (b << 3);
        const UINT32 i_base   = lpn_base - start_lpn;
        const UINT32 bit_lo = (b == byte_start)        ? (start_lpn & 7) : 0;
        const UINT32 bit_hi = (b == (byte_end_ex - 1)) ? (end_lpn   & 7) : 7;

        UINT8 range_mask = (UINT8)((0xFFu << bit_lo) & (0xFFu >> (7u - bit_hi)));
        UINT8 work = (UINT8)(bits & range_mask);
        if (!work) continue;

        for (UINT32 bit = bit_lo; bit <= bit_hi; ++bit) {
            UINT8 m = (UINT8)(1u << bit);
            if (!(work & m)) continue;

            UINT32 i = i_base + bit;
            if (i >= (UINT32)L2V_PER_META_PAGE) continue;

            UINT32 oldVPPN = pEntry->m_anL2V[i];
            if (oldVPPN == INVALID_PPN) continue;

            UINT32 nVBN = VBN_FROM_VPPN(oldVPPN);
            UINT32 channel = CHANNEL_FROM_VPPN(oldVPPN);
            UINT32 way = WAY_FROM_VPPN(oldVPPN);
            UINT32 vpn = VPN_FROM_VPPN(oldVPPN);

            BOOL bPhysicalExists = TRUE;

            if ((v->GetV2L(oldVPPN)) != (start_lpn + i))
            {
                bPhysicalExists = FALSE;
            }
            else if (v->IsValid(channel, way, nVBN, vpn) == FALSE)
            {
                bPhysicalExists = FALSE;
            }

            if (bPhysicalExists)
            {
                VBINFO* pstVBInfo = DFTL_GLOBAL::GetVBInfoMgr(channel, way)->GetVBInfo(nVBN);
                if (pstVBInfo->IsActive()) continue;
                if (DFTL_GLOBAL::GetGCMgr(channel, way)->return_VBN() == nVBN) continue;
            }

            // --- 논리적 상태 업데이트 (항상 수행) ---
            UINT32 nLPN = start_lpn + i;
            UINT32 cID  = DFTL_GLOBAL::GetInstance()->GetClusterID(nLPN);
            DFTL_GLOBAL::GetInstance()->m_util_pages[cID] -= 1;

            _safe_store_u32(&pEntry->m_anL2V[i], INVALID_PPN);
            touched = true;

            if (bPhysicalExists) {
                if (inv_cnt < (UINT32)L2V_PER_META_PAGE) {
                    old_vppns[inv_cnt] = oldVPPN;
                    ++inv_cnt;
                    TRIM_CNT += 1;
                }
            }
        }
    }
    if (touched) pEntry->m_bDirty = TRUE;

    if (inv_cnt) {
        for (UINT32 k = 0; k < inv_cnt; ++k) {
            v->Invalidate(old_vppns[k], 1);
            ubm->Invalidate(old_vppns[k]);
            DFTL_IncreaseProfile(Prof_Discard_CMT_Num);
        }
    }
    ClearTrimRange(start_lpn, end_lpn);
}

VOID
META_REQUEST::Initialize(META_REQUEST_STATUS nStatus, UINT32 nMetaLPN, VOID* pstMetaEntry, IOTYPE eIOType)
{
	UINT32 channel, way;
	channel = get_channel_from_lpn(nMetaLPN);
	way = get_way_from_lpn(nMetaLPN);
	m_nStatus		= nStatus;
	m_nMetaLPN		= nMetaLPN;
	m_pstMetaEntry	= pstMetaEntry;		// Meta Cache Entry
	m_bBufferHit	= FALSE;
	m_eIOType		= eIOType;
	m_nChannel = channel;
	m_nWay = way;
}

BOOL
META_REQUEST::Run(VOID)
{	
	BOOL bSuccess;
	switch (m_nStatus)
	{
	case META_REQUEST_READ_WAIT:
		bSuccess = _ProcessRead_Wait();
		break;

	case META_REQUEST_READ_DONE:
		bSuccess = _ProcessRead_Done();
		break;

	case META_REQUEST_WRITE_WAIT:
		bSuccess = _ProcessWrite_Wait();
		break;

	case META_REQUEST_WRITE_DONE:
		bSuccess = _ProcessWrite_Done();
		break;

	default:
		ASSERT(0);
		bSuccess = FALSE;
		break;
	}

	return bSuccess;
}

BOOL
META_REQUEST::AllocateBuf(VOID)
{
	DEBUG_ASSERT(m_pstBufEntry == NULL);

	// Allocate Buffer
	BUFFER_MGR*		pstBufferMgr = DFTL_GLOBAL::GetBufferMgr();
	m_pstBufEntry = pstBufferMgr->Allocate();

	return (m_pstBufEntry != NULL) ? TRUE : FALSE;
}

VOID
META_REQUEST::ReleaseBuf(VOID)
{
	if (m_pstBufEntry == NULL)
	{
		return;
	}

	BUFFER_MGR*		pstBufferMgr = DFTL_GLOBAL::GetBufferMgr();
	pstBufferMgr->Release(m_pstBufEntry);

	m_pstBufEntry = NULL;
}

BOOL
META_REQUEST::_ProcessRead_Done(VOID)
{
	DEBUG_ASSERT(m_nStatus == META_REQUEST_READ_DONE);

	UINT32				nBufAddr;

#if defined(WIN32)
	if (m_bBufferHit == FALSE)
	{
		VNAND*	pstVNandMgr = DFTL_GLOBAL::GetVNandMgr();
		pstVNandMgr->ReadPageSimul(m_nVPPN, m_pstBufEntry->m_pMainBuf);
	}
#endif

	nBufAddr = (UINT32)m_pstBufEntry->m_pMainBuf + (LOGICAL_PAGE_SIZE * LPN_OFFSET_FROM_VPPN(m_nVPPN));

	// copy L2P to cache entry
	META_MGR*			pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
	META_CACHE_ENTRY*	pstMetaEntry = (META_CACHE_ENTRY*)m_pstMetaEntry;
	pstMetaMgr->LoadDone((META_CACHE_ENTRY*)m_pstMetaEntry, (VOID*)nBufAddr);

#if defined(SUPPORT_DATA_VERIFICATION) || defined(WIN32)
	// Set LPN on main buffer to data verification
	//DEBUG_ASSERT(((unsigned int *)pstRequest->pSpareBuf)[nLPNOffset] == pstRequest->nLPN);
	if (((UINT32 *)m_pstBufEntry->m_pSpareBuf)[LPN_OFFSET_FROM_VPPN(m_nVPPN)] != m_nMetaLPN)
	{
		PRINTF("[FTL][META] LPN mismatch, request LPN: %d, SpareLPN: %d \n\r",
			m_nMetaLPN, ((UINT32 *)m_pstBufEntry->m_pSpareBuf)[LPN_OFFSET_FROM_VPPN(m_nVPPN)]);
		DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_MISCOMAPRE);
	}
#endif

	GoToNextStatus();

	META_REQUEST_INFO*	pstRequestInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();

	ReleaseBuf();

	if (TrimPending_IsOn())
	{
		pstMetaMgr->ApplyTrimOnLoadedEntry_OPT(pstMetaEntry, m_nMetaLPN);
//		CheckPendingTrim();
	}

	// Release Request
	pstRequestInfo->RemoveFromDoneQ(this);
	pstRequestInfo->ReleaseRequest(this);

	return TRUE;
}

FTL_REQUEST_ID
META_REQUEST::_GetRquestID(VOID)
{
	FTL_REQUEST_ID stReqID;

	if (m_nStatus  == META_REQUEST_READ_WAIT)
	{
		stReqID.stCommon.nType = FTL_REQUEST_ID_TYPE_META_READ;
	}
	else if (m_nStatus == META_REQUEST_WRITE_WAIT)
	{
		stReqID.stCommon.nType = FTL_REQUEST_ID_TYPE_WRITE;	// this type will be stored request id of PROGRAM_UNIT
	}
	else
	{
		ASSERT(0);	// Not implemented yet
	}

	stReqID.stMeta.nRequestIndex = m_nRequestIndex;
	DEBUG_ASSERT(stReqID.stMeta.nRequestIndex < META_REQUEST_COUNT);

	return stReqID;
}

BOOL
META_REQUEST::_ProcessRead_Wait(VOID)
{
	ASSERT(m_nStatus == HIL_REQUEST_READ_WAIT);

	REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
	BUFFER_MGR*		pstBufferMgr = DFTL_GLOBAL::GetBufferMgr();

	UINT32			nBufferingVPPN;
	UINT32			nLPN;
	UINT32			channel;
	UINT32			way;

	FTL_REQUEST_ID stReqID = _GetRquestID();

	BOOL			bDone = FALSE;

	nLPN = GetLPN();
	channel = get_channel_from_lpn(nLPN);
	way = get_way_from_lpn(nLPN);

	// GetPPN
	m_nVPPN = DFTL_GLOBAL::GetMetaL2VMgr()->GetL2V(nLPN);
	DEBUG_ASSERT(INVALID_PPN != m_nVPPN);

	// Check buffering 
	BUFFERING_LPN* pstBufferingLPN = DFTL_GLOBAL::GetMetaActiveBlockBufferingLPN(0, channel, way);
	nBufferingVPPN = pstBufferingLPN->ReadLPN(nLPN, m_pstBufEntry, 0, channel, way);
	if (nBufferingVPPN != INVALID_VPPN)
	{
		DEBUG_ASSERT(m_nVPPN == nBufferingVPPN);
		bDone = TRUE;
		m_bBufferHit = TRUE;
	}
	else
	{
		// VNNAD Read
		DFTL_GLOBAL::GetVNandMgr()->ReadPage(stReqID, m_nVPPN, m_pstBufEntry->m_pMainBuf, m_pstBufEntry->m_pSpareBuf);
		bDone = FALSE;
	}

	FTL_DEBUG_PRINTF("[FTL][META][WAITQ][Read] LPN:%d, Count: %d \r\n", pstRequest->nLPN, pstRequest->nLPNCount);

	GoToNextStatus();

	META_REQUEST_INFO*	pstMetaRequestInfo = pstRequestMgr->GetMetaRequestInfo();
#if (META_PER_WAY==1)
	pstMetaRequestInfo->RemoveFromWaitQ(this, channel, way);
#else
	pstMetaRequestInfo->RemoveFromWaitQ(this);
#endif
	if (bDone == TRUE)
	{
		GoToNextStatus();
		pstMetaRequestInfo->AddToDoneQ(this);	// Issued request will be done by FIL call back
	}
	else
	{
		pstMetaRequestInfo->AddToIssuedQ(this);	// Issued request will be done by FIL call back
	}

	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_META_READ);

	return TRUE;
}

BOOL
META_REQUEST::_ProcessWrite_Wait(VOID)
{
	// Get ActiveBlock
	ACTIVE_BLOCK*	pstActiveBlock;
	BOOL			bSuccess;
	UINT32 channel, way;
	if (_IsWritable() == FALSE)
	{
		return FALSE;
	}

	channel = get_channel_from_lpn(m_nMetaLPN);
	way = get_way_from_lpn(m_nMetaLPN);

	pstActiveBlock = DFTL_GLOBAL::GetActiveBlockMgr(0, channel, way)->GetActiveBlock(IOTYPE_META);
	bSuccess = pstActiveBlock->Write(this, 0, IOTYPE_META, IOTYPE_META);
	if (bSuccess == TRUE)
	{
		GoToNextStatus();

		//Remove from WaitQ
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		META_REQUEST_INFO*	pstMETARequestInfo = pstRequestMgr->GetMetaRequestInfo();
#if (META_PER_WAY==1)
		pstMETARequestInfo->RemoveFromWaitQ(this, channel, way);
#else
		pstMETARequestInfo->RemoveFromWaitQ(this);
#endif
		pstMETARequestInfo->AddToDoneQ(this);

		DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_META_WRITE);
	}

	return bSuccess;
}

BOOL
META_REQUEST::_IsWritable(VOID)
{
	// check buffer available
	if (DFTL_GLOBAL::GetBufferMgr()->GetFreeCount() == 0)
	{
		return FALSE;
	}
	return TRUE;
}

BOOL
META_REQUEST::_ProcessWrite_Done(VOID)
{
	REQUEST_MGR*		pstRequestMgr		= DFTL_GLOBAL::GetRequestMgr();
	META_REQUEST_INFO*	pstMETARequestInfo	= pstRequestMgr->GetMetaRequestInfo();

	META_MGR*			pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
	pstMetaMgr->StoreDone((META_CACHE_ENTRY*)m_pstMetaEntry);

	//Remove from DoneQ & Release Request
	pstMETARequestInfo->RemoveFromDoneQ(this);
	pstMETARequestInfo->ReleaseRequest(this);

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////
//
//	META REQUEST INFORMATION
//
///////////////////////////////////////////////////////////////////////////////////

VOID
META_REQUEST_INFO::Initialize(VOID)
{
	INIT_LIST_HEAD(&m_dlFree);
#if (META_PER_WAY==1)
	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			INIT_LIST_HEAD(&m_dlWait[channel][way]);
			m_nWaitCount[channel][way] = 0;
		}
	}
#else
	INIT_LIST_HEAD(&m_dlWait);
	m_nWaitCount = 0;
#endif
	INIT_LIST_HEAD(&m_dlIssued);
	INIT_LIST_HEAD(&m_dlDone);

	m_nFreeCount = 0;
	
	m_nIssuedCount = 0;
	m_nDoneCount = 0;

	for (int i = 0; i < META_REQUEST_COUNT; i++)
	{
		INIT_LIST_HEAD(&m_astRequestPool[i].m_dlList);
		m_astRequestPool[i].SetRequestIndex(i);
		ReleaseRequest(&m_astRequestPool[i]);
	}
}

META_REQUEST*
META_REQUEST_INFO::AllocateRequest(VOID)
{
	if (m_nFreeCount == 0)
	{
		return NULL;
	}

	DEBUG_ASSERT(list_empty(&m_dlFree) == FALSE);

	if (DFTL_GLOBAL::GetBufferMgr()->IsEmpty() == TRUE)
	{
		return NULL;
	}

	META_REQUEST*	pstRequest;

	pstRequest = list_first_entry(&m_dlFree, META_REQUEST, m_dlList);

	list_del_init(&pstRequest->m_dlList);

	m_nFreeCount--;

	DEBUG_ASSERT(pstRequest->GetStatus() == META_REQUEST_FREE);

	if (pstRequest->AllocateBuf() == FALSE)
	{
		ASSERT(0);
	}

	return pstRequest;
}
#if (META_PER_WAY==1)
VOID
META_REQUEST_INFO::AddToWaitQ(META_REQUEST* pstRequest, UINT32 channel, UINT32 way)
{
	list_add_tail(&pstRequest->m_dlList, &m_dlWait[channel][way]);
	m_nWaitCount[channel][way]++;

	DEBUG_ASSERT(m_nWaitCount[channel][way] <= META_REQUEST_COUNT);
}

VOID
META_REQUEST_INFO::RemoveFromWaitQ(META_REQUEST* pstRequest, UINT32 channel, UINT32 way)
{
	DEBUG_ASSERT(m_nWaitCount[channel][way] > 0);

	list_del_init(&pstRequest->m_dlList);
	m_nWaitCount[channel][way]--;
}
#else
VOID
META_REQUEST_INFO::AddToWaitQ(META_REQUEST* pstRequest)
{
	list_add_tail(&pstRequest->m_dlList, &m_dlWait);
	m_nWaitCount++;

	DEBUG_ASSERT(m_nWaitCount <= META_REQUEST_COUNT);
}

VOID
META_REQUEST_INFO::RemoveFromWaitQ(META_REQUEST* pstRequest)
{
	DEBUG_ASSERT(m_nWaitCount > 0);

	list_del_init(&pstRequest->m_dlList);
	m_nWaitCount--;
}
#endif
VOID
META_REQUEST_INFO::AddToIssuedQ(META_REQUEST* pstRequest)
{
	list_add_tail(&pstRequest->m_dlList, &m_dlIssued);
	m_nIssuedCount++;

	DEBUG_ASSERT(m_nIssuedCount <= (MAX(META_REQUEST_COUNT, META_REQUEST_COUNT)));
}

VOID
META_REQUEST_INFO::RemoveFromIssuedQ(META_REQUEST* pstRequest)
{
	DEBUG_ASSERT(m_nIssuedCount > 0);

	list_del_init(&pstRequest->m_dlList);
	m_nIssuedCount--;
}

VOID
META_REQUEST_INFO::AddToDoneQ(META_REQUEST* pstRequest)
{
	list_add_tail(&pstRequest->m_dlList, &m_dlDone);
	m_nDoneCount++;

	DEBUG_ASSERT(m_nDoneCount <= META_REQUEST_COUNT);
}

VOID
META_REQUEST_INFO::RemoveFromDoneQ(META_REQUEST* pstRequest)
{
	DEBUG_ASSERT(m_nDoneCount > 0);

	list_del_init(&pstRequest->m_dlList);
	m_nDoneCount--;
}
#if (META_PER_WAY==1)
META_REQUEST*
META_REQUEST_INFO::GetWaitRequest(UINT32 channel, UINT32 way)
{
	if (m_nWaitCount[channel][way] == 0)
	{

		DEBUG_ASSERT(list_empty(&m_dlWait[channel][way]) == TRUE);

		return NULL;
	}

	DEBUG_ASSERT(list_empty(&m_dlWait[channel][way]) == FALSE);

	META_REQUEST*	pstRequest;

	pstRequest = list_first_entry(&m_dlWait[channel][way], META_REQUEST, m_dlList);

	return pstRequest;
}
#else
META_REQUEST*
META_REQUEST_INFO::GetWaitRequest(VOID)

{

	if(m_nWaitCount == 0)
	{

		DEBUG_ASSERT(list_empty(&m_dlWait) == TRUE);

		return NULL;
	}

	DEBUG_ASSERT(list_empty(&m_dlWait) == FALSE);


	META_REQUEST*	pstRequest;

	pstRequest = list_first_entry(&m_dlWait, META_REQUEST, m_dlList);

	return pstRequest;
}
#endif

META_REQUEST*
META_REQUEST_INFO::GetDoneRequest(VOID)
{
	if (m_nDoneCount == 0)
	{
		DEBUG_ASSERT(list_empty(&m_dlDone) == TRUE);
		return NULL;
	}

	DEBUG_ASSERT(list_empty(&m_dlDone) == FALSE);

	META_REQUEST*	pstRequest;
	pstRequest = list_first_entry(&m_dlDone, META_REQUEST, m_dlList);

	return pstRequest;
}

VOID
META_REQUEST_INFO::ReleaseRequest(META_REQUEST* pstRequest)
{
	pstRequest->ReleaseBuf();

	list_add_tail(&pstRequest->m_dlList, &m_dlFree);
	m_nFreeCount++;
	DEBUG_ASSERT(m_nFreeCount <= META_REQUEST_COUNT);

	pstRequest->SetStatus(META_REQUEST_FREE);
	DEBUG_ASSERT(m_nFreeCount <= META_REQUEST_COUNT);
	DEBUG_ASSERT(_GetRequestIndex(pstRequest) < META_REQUEST_COUNT);
}

INT32
META_REQUEST_INFO::_GetRequestIndex(META_REQUEST* pstRequest)
{
	return pstRequest - &m_astRequestPool[0];
}

