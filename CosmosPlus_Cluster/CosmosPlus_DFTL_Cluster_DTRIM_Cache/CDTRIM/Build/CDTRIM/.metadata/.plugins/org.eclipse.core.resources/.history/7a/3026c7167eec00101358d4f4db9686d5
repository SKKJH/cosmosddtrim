/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "dftl_internal.h"

VOID
META_CACHE_ENTRY::Initialize(VOID)
{
	m_nMetaLPN = INVALID_LPN;
	INIT_LIST_HEAD(&m_dlList);
    INIT_LIST_HEAD(&m_dlHash);   //Hash kjh
    INIT_LIST_HEAD(&m_dlConfinedList);

	m_bValid = FALSE;
	m_bDirty = FALSE;
	m_bIORunning = FALSE;
	m_bConfined = FALSE;
}

VOID
META_CACHE::Initialize(VOID)
{
	INIT_LIST_HEAD(&m_dlLRU);
	INIT_LIST_HEAD(&m_dlFree);
	m_nFreeCount = 0;

	INIT_LIST_HEAD(&m_dlConfinedLRU);
	m_nConfinedCount = 0;

	m_nHit = 0;
	m_nMiss = 0;

// Meta
    for (INT32 i = 0; i < META_HASH_SIZE; ++i)
        INIT_LIST_HEAD(&m_ahHash[i]);
// Hash kjh

	for (INT32 i = 0; i < META_CACHE_ENTRY_COUNT; i++)
	{
		m_astCacheEntry[i].Initialize();

		_Release(&m_astCacheEntry[i]);
	}

	m_nFormatMetaLPN = INVALID_LPN;
}

BOOL
META_CACHE::Format(VOID)
{
	BOOL bRet;

	do
	{
		if (m_nFormatMetaLPN == INVALID_LPN)
		{
			m_nFormatMetaLPN = 0;
		}

		META_L2V_MGR*	pstMetaL2VMgr = DFTL_GLOBAL::GetMetaL2VMgr();
		if (m_nFormatMetaLPN >= pstMetaL2VMgr->GetMetaLPNCount())
		{
			// Format done
			bRet = TRUE;
			break;
		}

		META_CACHE_ENTRY*	pstEntry = _Allocate();
		if (pstEntry == NULL)
		{
			bRet = FALSE;
			break;
		}

		DEBUG_ASSERT(pstEntry->m_bValid == FALSE);
		DEBUG_ASSERT(pstEntry->m_bDirty == FALSE);
		DEBUG_ASSERT(pstEntry->m_bIORunning == FALSE);

		for (INT32 i = 0; i < L2V_PER_META_PAGE; i++)
		{
			pstEntry->m_anL2V[i] = INVALID_LPN; //L2V_PER_META_PAGE = 1024
		}

		pstEntry->m_bDirty = TRUE;
		pstEntry->m_bValid = TRUE;

		pstEntry->m_nMetaLPN = m_nFormatMetaLPN;

		_HashInsert(pstEntry); //Hash KJH

		m_nFormatMetaLPN++;

		bRet = FALSE;

	} while(0);

	return bRet;
}

//META_CACHE_ENTRY*
//META_CACHE::GetMetaEntry(UINT32 nLPN)
//{
//	static INT32	nPrevLPN;
//	UINT32	nMetaLPN = _GetMetaLPN(nLPN);
//    META_CACHE_ENTRY* pstEntry = _HashFind(nMetaLPN);
//
//    if (pstEntry != NULL) {
//        list_move_head(&pstEntry->m_dlList, &m_dlLRU);
//        DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_L2PCACHE_HIT);
//        nPrevLPN = nLPN;
//        return pstEntry;
//    }
//
//	if (nPrevLPN != nLPN)
//	{
//		DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_L2PCACHE_MISS);
//		nPrevLPN = nLPN;
//	}
//
//	return NULL;
//}

//META_CACHE_ENTRY*
//META_CACHE::GetMetaEntry(UINT32 nLPN, BOOL bIsMETA)
//{
//	static INT32	nPrevLPN;
//	UINT32	nMetaLPN = _GetMetaLPN(nLPN);
//    META_CACHE_ENTRY* pstEntry = _HashFind(nMetaLPN);
//
//    if (pstEntry != NULL) {
//        // [Updated] Pinning Logic
//        if (pstEntry->m_bConfined == TRUE)
//        {
//            if (bIsMETA == FALSE)
//            {
//                // Host Access: Unpin and Move to Head (Promote)
//                pstEntry->m_bConfined = FALSE;
//                list_move_head(&pstEntry->m_dlList, &m_dlLRU);
//            }
//            else
//            {
//                // GC Access: Keep Pinned, Do NOT move to Head (Keep at Tail/Current pos)
//                // Do nothing regarding LRU position
//            }
//        }
//        else
//        {
//            // Normal Entry: Move to Head
//            list_move_head(&pstEntry->m_dlList, &m_dlLRU);
//        }
//
//        DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_L2PCACHE_HIT);
//        nPrevLPN = nLPN;
//        return pstEntry;
//    }
//
//	if (nPrevLPN != nLPN)
//	{
//		DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_L2PCACHE_MISS);
//		nPrevLPN = nLPN;
//	}
//
//	return NULL;
//}

META_CACHE_ENTRY*
META_CACHE::GetMetaEntry(UINT32 nLPN, BOOL bIsMETA)
{
	static INT32	nPrevLPN;
	UINT32	nMetaLPN = _GetMetaLPN(nLPN);
	META_CACHE_ENTRY* pstEntry = _HashFind(nMetaLPN);

	if (pstEntry != NULL) {
		// [Case 1] 이미 Pin(Confined) 된 엔트리인 경우 (순수 GC용으로 로드된 상태)
		if (pstEntry->m_bConfined == TRUE)
		{
			if (bIsMETA == FALSE)
			{
				// Host가 접근: Pin을 해제하고 일반 데이터로 전환 -> Head(MRU)로 승격
				pstEntry->m_bConfined = FALSE;
				list_del_init(&pstEntry->m_dlConfinedList);
				m_nConfinedCount--;
				list_move_head(&pstEntry->m_dlList, &m_dlLRU);
			}
			else
			{
				// GC가 접근: 여전히 GC 용도이므로 Confined 리스트 내에서만 순서 갱신
                // Main LRU에서의 위치는 변경하지 않음 (보통 Tail 쪽에 있을 것임)
				list_move(&pstEntry->m_dlConfinedList, &m_dlConfinedLRU);
			}
		}
		// [Case 2] Pin 되지 않은 엔트리인 경우 (Host 데이터 또는 일반 데이터)
		else
		{
            // 요청사항 반영:
			// Host 접근: 당연히 Head(MRU)로 이동
			// GC 접근: "애초에 Host 데이터"이므로, Pin 걸지 말고 Head(MRU)로 이동하여 수명 연장
			list_move_head(&pstEntry->m_dlList, &m_dlLRU);
		}

		DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_L2PCACHE_HIT);
		nPrevLPN = nLPN;
		return pstEntry;
	}

	if (nPrevLPN != nLPN)
	{
		DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_L2PCACHE_MISS);
		nPrevLPN = nLPN;
	}

	return NULL;
}

BOOL
META_CACHE::IsMetaAvailable(UINT32 nLPN, BOOL bIsMETA)
{
#if (META_PER_WAY==1)
	UINT32 mod_lpn = get_mod_lpn(nLPN);
#else
	UINT32 mod_lpn = nLPN;
#endif
	META_CACHE_ENTRY*	pstEntry = GetMetaEntry(mod_lpn, bIsMETA);

	if (pstEntry == NULL)
	{
		return FALSE;
	}

	return (pstEntry->m_bValid == TRUE) ? TRUE : FALSE;
}

//VOID
//META_CACHE::ReleaseConfinedEntries(VOID)
//{
//    struct list_head* head = &m_dlLRU;
//    struct list_head* pos  = head->prev;
//    while (pos != head)
//    {
//        META_CACHE_ENTRY* e = list_entry(pos, META_CACHE_ENTRY, m_dlList);
//        if (e->m_bConfined == FALSE) {
//            break;
//        }
//        e->m_bConfined = FALSE;
//        pos = pos->prev;
//    }
//}

VOID
META_CACHE::ReleaseConfinedEntries(VOID)
{
	META_CACHE_ENTRY* e;
	META_CACHE_ENTRY* temp;
	list_for_each_entry_safe(META_CACHE_ENTRY, e, temp, &m_dlConfinedLRU, m_dlConfinedList)
	{
		e->m_bConfined = FALSE;
        list_del_init(&e->m_dlConfinedList);
        m_nConfinedCount--;
        list_move_head(&e->m_dlList, &m_dlLRU);
	}
    m_nConfinedCount = 0;
}

BOOL
META_CACHE::IsMetaWritable(UINT32 nLPN, BOOL bIsMETA)
{
#if (META_PER_WAY==1)
	UINT32 mod_lpn = get_mod_lpn(nLPN);
#else
	UINT32 mod_lpn = nLPN;
#endif
	META_CACHE_ENTRY*	pstEntry = GetMetaEntry(mod_lpn, bIsMETA);

	if (pstEntry == NULL)
	{
		return FALSE;
	}
	if (pstEntry->m_bValid == TRUE && pstEntry->m_bIORunning == FALSE)
		return TRUE;
	else
		return FALSE;
	
}


//VOID
//META_CACHE::LoadMeta(UINT32 nLPN, UINT32 DS_FLAG, BOOL bIsMETA)
//{
//#if (META_PER_WAY==1)
//	UINT32 mod_lpn = get_mod_lpn(nLPN);
//#else
//	UINT32 mod_lpn = nLPN;
//#endif
//
//#if (SUPPORT_META_DEMAND_LOADING == 1)
//	BOOL bIsGC;
//
//	if (bIsMETA == TRUE) bIsGC = TRUE;
//
//	META_CACHE_ENTRY*	pstEntry = GetMetaEntry(mod_lpn, bIsGC);
//
//	if (pstEntry != NULL)
//	{
//		DEBUG_ASSERT(pstEntry->m_bIORunning == TRUE);
//		DEBUG_ASSERT(pstEntry->m_bValid == FALSE);
//		return;
//	}
//
//	pstEntry = _Allocate();
//	if (pstEntry == NULL)
//	{
//		// busy
//		return;
//	}
//
//    // Hash KJH
//    pstEntry->m_nMetaLPN = _GetMetaLPN(mod_lpn);
//    _HashInsert(pstEntry);
//
//    // [Updated] Apply Pinning and LRU placement for GC/TRIM
//    if (bIsGC) {
//        pstEntry->m_bConfined = TRUE;
//        // Move to Tail (LRU end) so it is ready to be evicted immediately when unpinned
//        list_move_tail(&pstEntry->m_dlList, &m_dlLRU);
//    }
//    // Hash KJH
//
//	REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
//	META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
//	META_REQUEST*	pstRequest = pstRequestInfo->AllocateRequest();
//
//	if (pstRequest == NULL)
//	{
//		_HashRemove(pstEntry); // Hash KJH
//		// there is no free request
//		list_del_init(&pstEntry->m_dlList);
//		_Release(pstEntry);			// Release Meta entry
//		return;
//	}
//
////	pstEntry->m_nMetaLPN = _GetMetaLPN(mod_lpn);
//
//	pstRequest->Initialize(META_REQUEST_READ_WAIT, pstEntry->m_nMetaLPN, pstEntry, IOTYPE_META);
//#if (META_PER_WAY==1)
//	UINT32 channel, way;
//	channel = get_channel_from_lpn(pstEntry->m_nMetaLPN);
//	way = get_way_from_lpn(pstEntry->m_nMetaLPN);
//	pstRequestInfo->AddToWaitQ(pstRequest, channel, way);
//#else
//	pstRequestInfo->AddToWaitQ(pstRequest);
//#endif
//
//	pstEntry->m_bIORunning = TRUE;
//
//	if (DS_FLAG)
//		DFTL_IncreaseProfile(Prof_Discard_Load_Num);
//
//	META_DEBUG_PRINTF("[META] Load MetaLPN: %d \n\r", pstEntry->m_nMetaLPN);
//
//#else
//	ASSERT(0);
//#endif
//}

VOID
META_CACHE::LoadMeta(UINT32 nLPN, UINT32 DS_FLAG, BOOL bIsMETA)
{
#if (META_PER_WAY==1)
	UINT32 mod_lpn = get_mod_lpn(nLPN);
#else
	UINT32 mod_lpn = nLPN;
#endif

#if (SUPPORT_META_DEMAND_LOADING == 1)
	BOOL bIsGC = (bIsMETA == TRUE);
	META_CACHE_ENTRY* pstEntry = GetMetaEntry(mod_lpn, bIsGC);
	if (pstEntry != NULL)
	{
		return;
	}

    if (bIsGC && m_nConfinedCount > 16)
    {
        META_CACHE_ENTRY* pVictim = NULL;
        struct list_head* pPos = m_dlConfinedLRU.prev;
        while (pPos != &m_dlConfinedLRU)
        {
            META_CACHE_ENTRY* pCand = list_entry(pPos, META_CACHE_ENTRY, m_dlConfinedList);
            if (pCand->m_bIORunning == FALSE)
            {
                pVictim = pCand;
                break;
            }
            pPos = pPos->prev;
        }
        if (pVictim != NULL)
        {
            if (pVictim->m_bDirty == TRUE)
            {
                REQUEST_MGR* pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
                META_REQUEST_INFO* pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
                META_REQUEST* pstRequest = pstRequestInfo->AllocateRequest();
                if (pstRequest != NULL)
                {
                    pstRequest->Initialize(META_REQUEST_WRITE_WAIT, pVictim->m_nMetaLPN, pVictim, IOTYPE_META);
                    OSAL_MEMCPY(pstRequest->GetBuffer()->m_pMainBuf, &pVictim->m_anL2V[0], META_VPAGE_SIZE);

#if (META_PER_WAY==1)
                    UINT32 channel = get_channel_from_lpn(pVictim->m_nMetaLPN);
                    UINT32 way = get_way_from_lpn(pVictim->m_nMetaLPN);
                    pstRequestInfo->AddToWaitQ(pstRequest, channel, way);
#else
                    pstRequestInfo->AddToWaitQ(pstRequest);
#endif
                    DFTL_IncreaseProfile(Prof_CMT_write);
                    pVictim->m_bIORunning = TRUE;
                }
                return;
            }
            else
            {
                list_del_init(&pVictim->m_dlConfinedList);
                m_nConfinedCount--;
                _HashRemove(pVictim);
                list_del_init(&pVictim->m_dlList);
                pVictim->Initialize();
                _Release(pVictim);
                META_DEBUG_PRINTF("[META] Force Evict Pinned MetaLPN: %d \r\n", pVictim->m_nMetaLPN);
            }
        }
    }

	pstEntry = _Allocate();
	if (pstEntry == NULL)
	{
		return;
	}
	pstEntry->m_nMetaLPN = _GetMetaLPN(mod_lpn);
	_HashInsert(pstEntry);

    if (bIsGC) {
        pstEntry->m_bConfined = TRUE;
        list_add(&pstEntry->m_dlConfinedList, &m_dlConfinedLRU);
        m_nConfinedCount++;
        list_move_tail(&pstEntry->m_dlList, &m_dlLRU);
    }

	REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
	META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
	META_REQUEST*	pstRequest = pstRequestInfo->AllocateRequest();

	if (pstRequest == NULL)
	{
		_HashRemove(pstEntry);
        if (pstEntry->m_bConfined == TRUE) {
            list_del_init(&pstEntry->m_dlConfinedList);
            m_nConfinedCount--;
        }
		list_del_init(&pstEntry->m_dlList);
		_Release(pstEntry);
		return;
	}

	pstRequest->Initialize(META_REQUEST_READ_WAIT, pstEntry->m_nMetaLPN, pstEntry, IOTYPE_META);
#if (META_PER_WAY==1)
	UINT32 channel, way;
	channel = get_channel_from_lpn(pstEntry->m_nMetaLPN);
	way = get_way_from_lpn(pstEntry->m_nMetaLPN);
	pstRequestInfo->AddToWaitQ(pstRequest, channel, way);
#else
	pstRequestInfo->AddToWaitQ(pstRequest);
#endif
	pstEntry->m_bIORunning = TRUE;

	if (DS_FLAG)
		DFTL_IncreaseProfile(Prof_Discard_Load_Num);

	META_DEBUG_PRINTF("[META] Load MetaLPN: %d \n\r", pstEntry->m_nMetaLPN);

#else
	ASSERT(0);
#endif
}

UINT32
META_CACHE::GetL2V(UINT32 nLPN, BOOL bIsMETA)
{
	META_CACHE_ENTRY*		pstEntry;
#if (META_PER_WAY==1)
	UINT32 mod_lpn = get_mod_lpn(nLPN);
#else
	UINT32 mod_lpn = nLPN;
#endif

	pstEntry = GetMetaEntry(mod_lpn, bIsMETA);
	if (pstEntry == NULL)
		return INVALID_PPN;

	DEBUG_ASSERT(pstEntry->m_bValid == TRUE);

	UINT32 nOffset = mod_lpn % L2V_PER_META_PAGE;

	return pstEntry->m_anL2V[nOffset];
}

/*
	@brief	set a new VPPN,
	@return	OldVPPN
*/
UINT32
META_CACHE::SetL2V(UINT32 nLPN, UINT32 nVPPN, BOOL bIsMETA)
{
	META_CACHE_ENTRY*		pstEntry;
#if (META_PER_WAY==1)
	UINT32 mod_lpn = get_mod_lpn(nLPN);
#else
	UINT32 mod_lpn = nLPN;
#endif

	pstEntry = GetMetaEntry(mod_lpn, bIsMETA);
	ASSERT(pstEntry != NULL);

	DEBUG_ASSERT(pstEntry->m_bValid == TRUE);

	UINT32 nOffset = mod_lpn % L2V_PER_META_PAGE;

	UINT32 nOldVPPN = pstEntry->m_anL2V[nOffset];

	pstEntry->m_anL2V[nOffset] = nVPPN;

	pstEntry->m_bDirty = TRUE;

	return nOldVPPN;
}

UINT32
META_CACHE::get_mod_lpn(UINT32 nLPN) {
//	UINT32 nChannel = get_channel_from_lpn(nLPN);
//	UINT32 nWay = get_way_from_lpn(nLPN);
//	UINT32 nLBN = get_lbn_from_lpn(nLPN);
//	UINT32 nPage = get_page_from_lpn(nLPN);
//	UINT32 page_offset = nLPN % LPN_PER_PHYSICAL_PAGE;
//	UINT32 mod_lpn = get_mod_lpn_from_lpn_lbn(nChannel, nWay, nLBN, nPage) + page_offset;

	return nLPN;
}

UINT32
META_CACHE::_GetMetaLPN(UINT32 nLPN)
{
	return nLPN / L2V_PER_META_PAGE;
}

VOID
META_CACHE::_Release(META_CACHE_ENTRY* pstEntry)
{
	list_add_head(&pstEntry->m_dlList, &m_dlFree);
	m_nFreeCount++;
}

/*
	@brief	allocate a cache entry
*/

//META_CACHE_ENTRY*
//META_CACHE::_Allocate(VOID)
//{
//	META_CACHE_ENTRY*	pstEntry;
//	if (m_nFreeCount == 0)
//	{
//		DEBUG_ASSERT(list_empty(&m_dlFree) == TRUE);
//		pstEntry = list_last_entry(&m_dlLRU, META_CACHE_ENTRY, m_dlList);
//
//		if (pstEntry->m_bIORunning == TRUE)
//		{
//			// Programing on going
//			return NULL;
//		}
//
//		DEBUG_ASSERT(pstEntry->m_bValid == TRUE);
//
//
//		if (pstEntry->m_bDirty == TRUE)
//		{
//			// need to write this entry to NAND flash memory
//			// Add To Meta Write Queue
//			REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
//			META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
//			META_REQUEST*	pstRequest = pstRequestInfo->AllocateRequest();
//			if (pstRequest == NULL)
//			{
//				// there is no free reuqest
//				return NULL;
//			}
//
//			pstRequest->Initialize(META_REQUEST_WRITE_WAIT, pstEntry->m_nMetaLPN, pstEntry, IOTYPE_META);
//
//			// copy meta to buffer entry
//			OSAL_MEMCPY(pstRequest->GetBuffer()->m_pMainBuf, &pstEntry->m_anL2V[0], META_VPAGE_SIZE);
//#if (META_PER_WAY==1)
//			UINT32 channel, way;
//			channel = get_channel_from_lpn(pstEntry->m_nMetaLPN);
//			way = get_way_from_lpn(pstEntry->m_nMetaLPN);
//			pstRequestInfo->AddToWaitQ(pstRequest, channel, way);
//#else
//			pstRequestInfo->AddToWaitQ(pstRequest);
//#endif
//
//			DFTL_IncreaseProfile(Prof_CMT_write);
//			pstEntry->m_bIORunning = TRUE;
//			return NULL;
//		}
//
//		_HashRemove(pstEntry); //Hash KJH
//
//		META_DEBUG_PRINTF("[META] Evicted MetaLPN: %d \r\n", pstEntry->m_nMetaLPN);
//
//		ASSERT(pstEntry->m_bValid == TRUE);
//	}
//	else
//	{
//		pstEntry = list_first_entry(&m_dlFree, META_CACHE_ENTRY, m_dlList);
//		m_nFreeCount--;
//	}
//
//	list_move_head(&pstEntry->m_dlList, &m_dlLRU);
//
//	pstEntry->m_bValid = FALSE;
//	ASSERT(pstEntry->m_bDirty == FALSE);
//	ASSERT(pstEntry->m_bIORunning == FALSE);
//
//	return pstEntry;
//}

META_CACHE_ENTRY*
META_CACHE::_Allocate(VOID)
{
	META_CACHE_ENTRY*	pstEntry = NULL;

	if (m_nFreeCount == 0)
	{
		DEBUG_ASSERT(list_empty(&m_dlFree) == TRUE);
		struct list_head* pHead = &m_dlLRU;
		struct list_head* pPos = pHead->prev;
		int ConfinedCount = 0;

		while (pPos != pHead)
		{
			pstEntry = list_entry(pPos, META_CACHE_ENTRY, m_dlList);
			if (pstEntry->m_bIORunning == FALSE && pstEntry->m_bConfined == FALSE)
			{
				break;
			}

			if(pstEntry->m_bConfined == TRUE)
				ConfinedCount++;

			pPos = pPos->prev;
			pstEntry = NULL;
		}

		if (pstEntry == NULL)
		{
			xil_printf("No victim found (All entries are either pinned[%u] or doing IO)\r\n", ConfinedCount);
			return NULL;
		}

		DEBUG_ASSERT(pstEntry->m_bValid == TRUE);

		if (pstEntry->m_bDirty == TRUE)
		{
			REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
			META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
			META_REQUEST*	pstRequest = pstRequestInfo->AllocateRequest();
			if (pstRequest == NULL)
			{
				return NULL;
			}

			pstRequest->Initialize(META_REQUEST_WRITE_WAIT, pstEntry->m_nMetaLPN, pstEntry, IOTYPE_META);

			OSAL_MEMCPY(pstRequest->GetBuffer()->m_pMainBuf, &pstEntry->m_anL2V[0], META_VPAGE_SIZE);
#if (META_PER_WAY==1)
			UINT32 channel, way;
			channel = get_channel_from_lpn(pstEntry->m_nMetaLPN);
			way = get_way_from_lpn(pstEntry->m_nMetaLPN);
			pstRequestInfo->AddToWaitQ(pstRequest, channel, way);
#else
			pstRequestInfo->AddToWaitQ(pstRequest);
#endif
			DFTL_IncreaseProfile(Prof_CMT_write);
			pstEntry->m_bIORunning = TRUE;
			return NULL;
		}
		_HashRemove(pstEntry);

		META_DEBUG_PRINTF("[META] Evicted MetaLPN: %d \r\n", pstEntry->m_nMetaLPN);
		ASSERT(pstEntry->m_bValid == TRUE);
	}
	else
	{
		pstEntry = list_first_entry(&m_dlFree, META_CACHE_ENTRY, m_dlList);
		m_nFreeCount--;
	}

	list_move_head(&pstEntry->m_dlList, &m_dlLRU);

	pstEntry->m_bValid = FALSE;
	pstEntry->m_bConfined = FALSE; // [Added] Reset confined flag
	ASSERT(pstEntry->m_bDirty == FALSE);
	ASSERT(pstEntry->m_bIORunning == FALSE);

	return pstEntry;
}

// Hash KJH
META_CACHE_ENTRY* META_CACHE::_HashFind(UINT32 nMetaLPN)
{
    UINT32 idx = _HashIdx(nMetaLPN);
    META_CACHE_ENTRY* e;
    list_for_each_entry(META_CACHE_ENTRY, e, &m_ahHash[idx], m_dlHash) {
        if (e->m_nMetaLPN == nMetaLPN) return e;
    }
    return NULL;
}
VOID META_CACHE::_HashInsert(META_CACHE_ENTRY* e)
{
    UINT32 idx = _HashIdx(e->m_nMetaLPN);
    list_add_head(&e->m_dlHash, &m_ahHash[idx]);
}
VOID META_CACHE::_HashRemove(META_CACHE_ENTRY* e)
{
    list_del_init(&e->m_dlHash);
}
// Hash KJH
///////////////////////////////////////////////////////////////////////////////////
//
//	Meta Manager
//
///////////////////////////////////////////////////////////////////////////////////

VOID
META_MGR::Initialize(VOID)
{
	m_stMetaCache.Initialize();
#if (SUPPORT_META_DEMAND_LOADING == 1)
	
#else
	m_panL2V = (UINT32*)OSAL_MemAlloc(MEM_TYPE_FW_DATA, _GetL2PSize(), OSAL_MEMALLOC_FW_ALIGNMENT);
#endif

	m_bFormatted = FALSE;
}

BOOL
META_MGR::Format(VOID)
{
	if (m_bFormatted == TRUE)
	{
		return TRUE;
	}

	BOOL	bRet;

	bRet = m_stMetaCache.Format();
#if (SUPPORT_META_DEMAND_LOADING == 1)
#else
	OSAL_MEMSET(m_panL2V, 0xFF, _GetL2PSize());		// set invalid LPN
	bRet = TRUE;
#endif

	if (bRet == TRUE)
	{
		m_nVPC = 0;
		m_bFormatted = TRUE;
	}

	return bRet;
}

BOOL
META_MGR::IsMetaAvailable(UINT32 nLPN, BOOL bIsMETA)
{
#if (SUPPORT_META_DEMAND_LOADING == 1)
	return m_stMetaCache.IsMetaAvailable(nLPN, bIsMETA);
#else
	return TRUE;
#endif
}

BOOL
META_MGR::IsMetaWritable(UINT32 nLPN, BOOL bIsMETA)
{
#if (SUPPORT_META_DEMAND_LOADING == 1)
	return m_stMetaCache.IsMetaWritable(nLPN, bIsMETA);
#else
	return TRUE;
#endif
}

VOID
META_MGR::LoadMeta(UINT32 nLPN, UINT32 DS_FLAG, BOOL bIsMETA)
{
#if (SUPPORT_META_DEMAND_LOADING == 1)
	return m_stMetaCache.LoadMeta(nLPN, DS_FLAG, bIsMETA);
#else
	return;
#endif
}

VOID
META_MGR::LoadDone(META_CACHE_ENTRY* pstMetaEntry, VOID* pBuf)
{
	DEBUG_ASSERT(FALSE == pstMetaEntry->m_bValid);
	DEBUG_ASSERT(FALSE == pstMetaEntry->m_bDirty);
	DEBUG_ASSERT(TRUE == pstMetaEntry->m_bIORunning);

	pstMetaEntry->m_bIORunning = FALSE;
	pstMetaEntry->m_bDirty = FALSE;
	pstMetaEntry->m_bValid = TRUE;

	OSAL_MEMCPY(&pstMetaEntry->m_anL2V[0], pBuf, META_VPAGE_SIZE);
}

VOID
META_MGR::StoreDone(META_CACHE_ENTRY* pstMetaEntry)
{
	DEBUG_ASSERT(TRUE == pstMetaEntry->m_bValid);
	DEBUG_ASSERT(TRUE == pstMetaEntry->m_bDirty);
	DEBUG_ASSERT(TRUE == pstMetaEntry->m_bIORunning);

	pstMetaEntry->m_bIORunning = FALSE;
	pstMetaEntry->m_bDirty = FALSE;
}

UINT32
META_MGR::GetL2V(UINT32 nLPN, BOOL bIsMETA)
{
	DEBUG_ASSERT(nLPN < DFTL_GLOBAL::GetInstance()->GetLPNCount());

#if (SUPPORT_META_DEMAND_LOADING == 1)
	return m_stMetaCache.GetL2V(nLPN, bIsMETA);
#else
	return	m_panL2V[nLPN];
#endif
}

VOID
META_MGR::SetL2V(UINT32 nLPN, UINT32 nVPPN, UINT32 DS_FLAG, BOOL bIsMETA)
{
	DEBUG_ASSERT(nLPN < DFTL_GLOBAL::GetInstance()->GetLPNCount());

	UINT32	nOldVPPN;

#if (SUPPORT_META_DEMAND_LOADING == 1)
	nOldVPPN = m_stMetaCache.SetL2V(nLPN, nVPPN, bIsMETA);
#else
	nOldVPPN = m_panL2V[nLPN];

	m_panL2V[nLPN] = nVPPN;
#endif

	UINT32 cID = DFTL_GLOBAL::GetInstance()->GetClusterID(nLPN);
	if (DS_FLAG != 1)
	{
		DFTL_GLOBAL::GetInstance()->m_util_pages[cID] += 1;
	}

	if (nOldVPPN == INVALID_PPN)
	{
		m_nVPC++;
	}
	else
	{
		VNAND* pstVNand = DFTL_GLOBAL::GetVNandMgr();
		if (pstVNand->GetV2L(nOldVPPN) == nLPN)
		{
			UINT32 cID = DFTL_GLOBAL::GetInstance()->GetClusterID(nLPN);
			DFTL_GLOBAL::GetInstance()->m_util_pages[cID] -= 1;

			// Invalidate OLD PPN
			VNAND*	pstVNand = DFTL_GLOBAL::GetVNandMgr();
			DEBUG_ASSERT(pstVNand->GetV2L(nOldVPPN) == nLPN);
			DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_OVERWRITE);

			pstVNand->Invalidate(nOldVPPN, DS_FLAG);
			DFTL_GLOBAL::GetInstance()->GetUserBlockMgr()->Invalidate(nOldVPPN);
		}
	}
}

//VOID
//META_MGR::SetL2V(UINT32 nLPN, UINT32 nVPPN, UINT32 DS_FLAG, BOOL bIsMETA)		//0102
//{
//	DEBUG_ASSERT(nLPN < DFTL_GLOBAL::GetInstance()->GetLPNCount());
//
//	UINT32	nOldVPPN;
//
//#if (SUPPORT_META_DEMAND_LOADING == 1)
//	nOldVPPN = m_stMetaCache.SetL2V(nLPN, nVPPN, bIsMETA);
//#else
//	nOldVPPN = m_panL2V[nLPN];
//	m_panL2V[nLPN] = nVPPN;
//#endif
//
//	if (DS_FLAG != 1 && nVPPN != INVALID_PPN)
//	{
//		UINT32 cID = DFTL_GLOBAL::GetInstance()->GetClusterID(nLPN);
//		DFTL_GLOBAL::GetInstance()->m_util_pages[cID] += 1;
//	}
//
//	if (nOldVPPN == INVALID_PPN)
//	{
//        if (nVPPN != INVALID_PPN)
//        {
//		    m_nVPC++;
//        }
//	}
//	else
//	{
//		UINT32 cID = DFTL_GLOBAL::GetInstance()->GetClusterID(nLPN);
//		DFTL_GLOBAL::GetInstance()->m_util_pages[cID] -= 1;
//
//		VNAND*	pstVNand = DFTL_GLOBAL::GetVNandMgr();
//
//		if (pstVNand->GetV2L(nOldVPPN) == nLPN)
//        {
//		    DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_OVERWRITE);
//		    pstVNand->Invalidate(nOldVPPN, DS_FLAG);
//		    DFTL_GLOBAL::GetInstance()->GetUserBlockMgr()->Invalidate(nOldVPPN);
//        }
//	}
//}

/*
@brief	return L2p SIZE IN BYTE
*/
INT32
META_MGR::_GetL2PSize(VOID)
{
	return sizeof(UINT32) * DFTL_GLOBAL::GetInstance()->GetLPNCount();
}

///////////////////////////////////////////////////////////////////////////////////
//
//	Meta L2V Manager
//
///////////////////////////////////////////////////////////////////////////////////

VOID
META_L2V_MGR::Initialize(VOID)
{
	m_panL2V = (UINT32*)OSAL_MemAlloc(MEM_TYPE_FW_DATA, _GetL2PSize(), OSAL_MEMALLOC_FW_ALIGNMENT);

	m_bFormatted = FALSE;
}

BOOL
META_L2V_MGR::Format(VOID)
{
	if (m_bFormatted == TRUE)
	{
		return TRUE;
	}

	OSAL_MEMSET(m_panL2V, 0xFF, _GetL2PSize());		// set invalid LPN

	m_nVPC = 0;
	m_bFormatted = TRUE;

	return TRUE;
}

UINT32
META_L2V_MGR::GetMetaLPNCount(VOID)
{
	UINT32	nLPNCount	= DFTL_GLOBAL::GetInstance()->GetLPNCount();
	return CEIL(((INT32)nLPNCount), (INT32)L2V_PER_META_PAGE);
}

UINT32
META_L2V_MGR::GetL2V(UINT32 nLPN)
{
	DEBUG_ASSERT(nLPN < GetMetaLPNCount());
	return	m_panL2V[nLPN];
}

VOID
META_L2V_MGR::SetL2V(UINT32 nLPN, UINT32 nVPPN)
{
#if (SUPPORT_META_DEMAND_LOADING == 1)
	DEBUG_ASSERT(nLPN < GetMetaLPNCount());

	BOOL	bOverWrite;

	if (m_panL2V[nLPN] != INVALID_PPN)
	{
		// Invalidate OLD PPN
		UINT32 nOldVPPN = m_panL2V[nLPN];
		VNAND*	pstVNand = DFTL_GLOBAL::GetVNandMgr();
		DEBUG_ASSERT(pstVNand->GetV2L(nOldVPPN) == nLPN);

		pstVNand->Invalidate(nOldVPPN, 2);

		DFTL_GLOBAL::GetInstance()->GetMetaBlockMgr()->Invalidate(nOldVPPN);

		bOverWrite = TRUE;
	}
	else
	{
		bOverWrite = FALSE;
	}

	m_panL2V[nLPN] = nVPPN;

	if (bOverWrite == FALSE)
	{
		m_nVPC++;
	}
#else
	ASSERT(0);		// check option
#endif
}

/*
@brief	return L2p SIZE IN BYTE
*/
INT32
META_L2V_MGR::_GetL2PSize(VOID)
{
	return sizeof(UINT32) * GetMetaLPNCount();
}
