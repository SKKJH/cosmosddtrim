///*******************************************************
//*
//* Copyright (C) 2018-2019
//* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
//*
//* This file is part of ESLab's Flash memory firmware
//*
//* This source can not be copied and/or distributed without the express
//* permission of ESLab
//*
//* Author: DongYoung Seo (dongyoung.seo@gmail.com)
//* ESLab: http://nyx.skku.ac.kr
//*
//*******************************************************/
//#include "assert.h"
//#include "xil_types.h"
//#include "debug.h"
//
//#include "cosmos_plus_system.h"
//#include "cosmos_plus_memory_map.h"
//
//#ifdef GREEDY_FTL
//#include "request_schedule.h"
//#endif
//
//#include "cosmos_plus_system.h"
//
//#include "fil.h"
//#include "fil_nand.h"
//#include "../Target/osal.h"
//#include "fil_request.h"
//
//static void _AddToWaitQ(FTL_REQUEST_TYPE nReqType, FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf);
//static BOOL anBadPBN[USER_CHANNELS][USER_WAYS][TOTAL_BLOCKS_PER_DIE / 8];
//
//void set_badPBN(UINT32 channel, UINT32 way, UINT32 pblk)
//{
//	UINT32 offset = pblk >> 3;
//	UINT32 offset_in_byte = pblk % 8;
//
//	anBadPBN[channel][way][offset] |= 1 << offset_in_byte;
//
//}
//void FIL_Initialize(void)
//{
//	NAND_Initialize();
//	FIL_InitRequest();
//	memset(&anBadPBN[0][0][0], 0, USER_CHANNELS * USER_WAYS * TOTAL_BLOCKS_PER_DIE / 8);
//	/*set_badPBN(1, 1, 256);
//	set_badPBN(1, 1, 320);
//	set_badPBN(1, 1, 330);
//
//
//	set_badPBN(2, 3, 415);
//	set_badPBN(2, 3, 481);
//	set_badPBN(2, 3, 505);
//	set_badPBN(2, 3, 565);
//	set_badPBN(2, 3, 585);
//
//	set_badPBN(3, 3, 517);
//	set_badPBN(3, 3, 527);
//	set_badPBN(3, 3, 579);*/
//
//#ifndef WIN32
//	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
//		for (UINT32 way = 0; way < USER_WAYS; way++)
//		{
//			set_badPBN(channel, way, 1219);
//			set_badPBN(channel, way, 1313);
//			set_badPBN(channel, way, 1325);
//			set_badPBN(channel, way, 1404);
//			set_badPBN(channel, way, 1469);
//			set_badPBN(channel, way, 1493);
//			set_badPBN(channel, way, 1722);
//			set_badPBN(channel, way, 1761);
//			set_badPBN(channel, way, 1801);
//			set_badPBN(channel, way, 1831);
//			set_badPBN(channel, way, 1847);
//			set_badPBN(channel, way, 1996);
//			set_badPBN(channel, way, 1998);
//			set_badPBN(channel, way, 2004);
//			set_badPBN(channel, way, 2157);
//			set_badPBN(channel, way, 2179);
//			set_badPBN(channel, way, 2259);
//			set_badPBN(channel, way, 2283);
//			set_badPBN(channel, way, 2327);
//			set_badPBN(channel, way, 2414);
//			set_badPBN(channel, way, 2467);
//			set_badPBN(channel, way, 2480);
//			set_badPBN(channel, way, 2496);
//			set_badPBN(channel, way, 2520);
//			set_badPBN(channel, way, 2593);
//			set_badPBN(channel, way, 2608);
//			set_badPBN(channel, way, 2610);
//			set_badPBN(channel, way, 2634);
//			set_badPBN(channel, way, 2753);
//			set_badPBN(channel, way, 2842);
//			set_badPBN(channel, way, 2852);
//			set_badPBN(channel, way, 2871);
//			set_badPBN(channel, way, 2894);
//			set_badPBN(channel, way, 2978);
//			set_badPBN(channel, way, 3051);
//			set_badPBN(channel, way, 3055);
//			set_badPBN(channel, way, 3111);
//			set_badPBN(channel, way, 3156);
//			set_badPBN(channel, way, 3157);
//			set_badPBN(channel, way, 3203);
//			set_badPBN(channel, way, 3226);
//			set_badPBN(channel, way, 3328);
//			set_badPBN(channel, way, 3342);
//			set_badPBN(channel, way, 3387);
//			set_badPBN(channel, way, 3449);
//			set_badPBN(channel, way, 3458);
//			set_badPBN(channel, way, 3468);
//			set_badPBN(channel, way, 3469);
//			set_badPBN(channel, way, 3475);
//			set_badPBN(channel, way, 3476);
//			set_badPBN(channel, way, 3477);
//			set_badPBN(channel, way, 3493);
//			set_badPBN(channel, way, 3561);
//			set_badPBN(channel, way, 3565);
//			set_badPBN(channel, way, 3614);
//			set_badPBN(channel, way, 3680);
//			set_badPBN(channel, way, 3760);
//			set_badPBN(channel, way, 3769);
//			set_badPBN(channel, way, 3834);
//			set_badPBN(channel, way, 3885);
//			set_badPBN(channel, way, 3900);
//			set_badPBN(channel, way, 3988);
//			set_badPBN(channel, way, 4057);
//			set_badPBN(channel, way, 4064);
//			set_badPBN(channel, way, 4089);
//			set_badPBN(channel, way, 4161);
//			set_badPBN(channel, way, 4184);
//			set_badPBN(channel, way, 4185);
//			set_badPBN(channel, way, 4186);
//			set_badPBN(channel, way, 4187);
//			set_badPBN(channel, way, 4188);
//			set_badPBN(channel, way, 4189);
//			set_badPBN(channel, way, 4190);
//			set_badPBN(channel, way, 4191);
//			set_badPBN(channel, way, 4192);
//			set_badPBN(channel, way, 4193);
//			set_badPBN(channel, way, 4194);
//			set_badPBN(channel, way, 4195);
//			set_badPBN(channel, way, 4196);
//			set_badPBN(channel, way, 4197);
//			set_badPBN(channel, way, 4198);
//			set_badPBN(channel, way, 4199);
//			set_badPBN(channel, way, 4200);
//			set_badPBN(channel, way, 4201);
//			set_badPBN(channel, way, 4202);
//			set_badPBN(channel, way, 4203);
//			set_badPBN(channel, way, 4204);
//			set_badPBN(channel, way, 4205);
//			set_badPBN(channel, way, 4206);
//			set_badPBN(channel, way, 4207);
//			set_badPBN(channel, way, 4208);
//			set_badPBN(channel, way, 4209);
//			set_badPBN(channel, way, 4210);
//			set_badPBN(channel, way, 4211);
//			set_badPBN(channel, way, 4212);
//			set_badPBN(channel, way, 4213);
//			set_badPBN(channel, way, 4214);
//			set_badPBN(channel, way, 4215);
//			set_badPBN(channel, way, 4216);
//			set_badPBN(channel, way, 4217);
//			set_badPBN(channel, way, 4218);
//			set_badPBN(channel, way, 4219);
//			set_badPBN(channel, way, 4220);
//			set_badPBN(channel, way, 4221);
//			set_badPBN(channel, way, 4222);
//			set_badPBN(channel, way, 4223);
//			set_badPBN(channel, way, 4224);
//			set_badPBN(channel, way, 4225);
//			set_badPBN(channel, way, 4226);
//			set_badPBN(channel, way, 4227);
//			set_badPBN(channel, way, 4228);
//			set_badPBN(channel, way, 4229);
//			set_badPBN(channel, way, 4230);
//			set_badPBN(channel, way, 4231);
//			set_badPBN(channel, way, 4232);
//			set_badPBN(channel, way, 4233);
//			set_badPBN(channel, way, 4234);
//			set_badPBN(channel, way, 4235);
//			set_badPBN(channel, way, 4236);
//			set_badPBN(channel, way, 4237);
//			set_badPBN(channel, way, 4238);
//			set_badPBN(channel, way, 4239);
//			set_badPBN(channel, way, 4240);
//			set_badPBN(channel, way, 4241);
//			set_badPBN(channel, way, 4242);
//			set_badPBN(channel, way, 4243);
//			set_badPBN(channel, way, 4244);
//			set_badPBN(channel, way, 4245);
//			set_badPBN(channel, way, 4246);
//			set_badPBN(channel, way, 4247);
//			set_badPBN(channel, way, 4248);
//			set_badPBN(channel, way, 4249);
//			set_badPBN(channel, way, 4250);
//			set_badPBN(channel, way, 4251);
//			set_badPBN(channel, way, 4252);
//			set_badPBN(channel, way, 4253);
//			set_badPBN(channel, way, 4254);
//			set_badPBN(channel, way, 4255);
//			set_badPBN(channel, way, 4256);
//			set_badPBN(channel, way, 4257);
//			set_badPBN(channel, way, 4258);
//			set_badPBN(channel, way, 4259);
//			set_badPBN(channel, way, 4260);
//			set_badPBN(channel, way, 4261);
//			set_badPBN(channel, way, 4262);
//			set_badPBN(channel, way, 4263);
//			set_badPBN(channel, way, 4264);
//			set_badPBN(channel, way, 4265);
//			set_badPBN(channel, way, 4266);
//			set_badPBN(channel, way, 4267);
//			set_badPBN(channel, way, 4268);
//			set_badPBN(channel, way, 4269);
//			set_badPBN(channel, way, 4270);
//			set_badPBN(channel, way, 4271);
//			set_badPBN(channel, way, 4272);
//			set_badPBN(channel, way, 4273);
//			set_badPBN(channel, way, 4274);
//			set_badPBN(channel, way, 4275);
//			set_badPBN(channel, way, 4276);
//			set_badPBN(channel, way, 4277);
//			set_badPBN(channel, way, 4278);
//			set_badPBN(channel, way, 4279);
//			set_badPBN(channel, way, 4280);
//			set_badPBN(channel, way, 4281);
//			set_badPBN(channel, way, 4282);
//			set_badPBN(channel, way, 4283);
//			set_badPBN(channel, way, 4284);
//			set_badPBN(channel, way, 4285);
//			set_badPBN(channel, way, 4286);
//			set_badPBN(channel, way, 4287);
//			set_badPBN(channel, way, 4288);
//			set_badPBN(channel, way, 4289);
//			set_badPBN(channel, way, 4290);
//			set_badPBN(channel, way, 4291);
//			set_badPBN(channel, way, 4292);
//			set_badPBN(channel, way, 4293);
//			set_badPBN(channel, way, 4294);
//			set_badPBN(channel, way, 4295);
//			set_badPBN(channel, way, 4296);
//			set_badPBN(channel, way, 4297);
//			set_badPBN(channel, way, 4298);
//			set_badPBN(channel, way, 4299);
//			set_badPBN(channel, way, 4300);
//			set_badPBN(channel, way, 4301);
//			set_badPBN(channel, way, 4302);
//			set_badPBN(channel, way, 4303);
//			set_badPBN(channel, way, 4304);
//			set_badPBN(channel, way, 4305);
//			set_badPBN(channel, way, 4306);
//			set_badPBN(channel, way, 4307);
//			set_badPBN(channel, way, 4308);
//			set_badPBN(channel, way, 4309);
//			set_badPBN(channel, way, 4310);
//			set_badPBN(channel, way, 4311);
//			set_badPBN(channel, way, 4312);
//			set_badPBN(channel, way, 4313);
//			set_badPBN(channel, way, 4314);
//			set_badPBN(channel, way, 4315);
//			set_badPBN(channel, way, 4316);
//			set_badPBN(channel, way, 4317);
//			set_badPBN(channel, way, 4318);
//			set_badPBN(channel, way, 4319);
//			set_badPBN(channel, way, 4320);
//			set_badPBN(channel, way, 4321);
//			set_badPBN(channel, way, 4322);
//			set_badPBN(channel, way, 4323);
//			set_badPBN(channel, way, 4324);
//			set_badPBN(channel, way, 4325);
//			set_badPBN(channel, way, 4326);
//			set_badPBN(channel, way, 4327);
//			set_badPBN(channel, way, 4328);
//			set_badPBN(channel, way, 4329);
//			set_badPBN(channel, way, 4330);
//			set_badPBN(channel, way, 4331);
//			set_badPBN(channel, way, 4332);
//			set_badPBN(channel, way, 4333);
//			set_badPBN(channel, way, 4334);
//			set_badPBN(channel, way, 4335);
//			set_badPBN(channel, way, 4336);
//			set_badPBN(channel, way, 4337);
//			set_badPBN(channel, way, 4338);
//			set_badPBN(channel, way, 4339);
//			set_badPBN(channel, way, 4340);
//			set_badPBN(channel, way, 4341);
//			set_badPBN(channel, way, 4342);
//			set_badPBN(channel, way, 4343);
//			set_badPBN(channel, way, 4344);
//			set_badPBN(channel, way, 4345);
//			set_badPBN(channel, way, 4346);
//			set_badPBN(channel, way, 4347);
//			set_badPBN(channel, way, 4348);
//			set_badPBN(channel, way, 4349);
//			set_badPBN(channel, way, 4350);
//			set_badPBN(channel, way, 4351);
//			set_badPBN(channel, way, 4352);
//			set_badPBN(channel, way, 4353);
//			set_badPBN(channel, way, 4354);
//			set_badPBN(channel, way, 4355);
//			set_badPBN(channel, way, 4356);
//			set_badPBN(channel, way, 4357);
//			set_badPBN(channel, way, 4358);
//			set_badPBN(channel, way, 4359);
//			set_badPBN(channel, way, 4360);
//			set_badPBN(channel, way, 4361);
//			set_badPBN(channel, way, 4362);
//			set_badPBN(channel, way, 4363);
//			set_badPBN(channel, way, 4364);
//			set_badPBN(channel, way, 4365);
//			set_badPBN(channel, way, 4366);
//			set_badPBN(channel, way, 4367);
//			set_badPBN(channel, way, 4368);
//			set_badPBN(channel, way, 4369);
//			set_badPBN(channel, way, 4370);
//			set_badPBN(channel, way, 4371);
//			set_badPBN(channel, way, 4372);
//			set_badPBN(channel, way, 4373);
//			set_badPBN(channel, way, 4374);
//			set_badPBN(channel, way, 4375);
//			set_badPBN(channel, way, 4376);
//			set_badPBN(channel, way, 4377);
//			set_badPBN(channel, way, 4378);
//			set_badPBN(channel, way, 4379);
//			set_badPBN(channel, way, 4380);
//			set_badPBN(channel, way, 4381);
//			set_badPBN(channel, way, 4382);
//			set_badPBN(channel, way, 4383);
//			set_badPBN(channel, way, 4384);
//			set_badPBN(channel, way, 4385);
//			set_badPBN(channel, way, 4386);
//			set_badPBN(channel, way, 4387);
//			set_badPBN(channel, way, 4388);
//			set_badPBN(channel, way, 4389);
//			set_badPBN(channel, way, 4390);
//			set_badPBN(channel, way, 4391);
//			set_badPBN(channel, way, 4392);
//			set_badPBN(channel, way, 4393);
//			set_badPBN(channel, way, 4394);
//			set_badPBN(channel, way, 4395);
//			set_badPBN(channel, way, 4396);
//			set_badPBN(channel, way, 4397);
//			set_badPBN(channel, way, 4398);
//			set_badPBN(channel, way, 4399);
//			set_badPBN(channel, way, 4400);
//			set_badPBN(channel, way, 4401);
//			set_badPBN(channel, way, 4402);
//			set_badPBN(channel, way, 4403);
//			set_badPBN(channel, way, 4404);
//			set_badPBN(channel, way, 4405);
//			set_badPBN(channel, way, 4406);
//			set_badPBN(channel, way, 4407);
//			set_badPBN(channel, way, 4408);
//			set_badPBN(channel, way, 4409);
//			set_badPBN(channel, way, 4410);
//			set_badPBN(channel, way, 4411);
//			set_badPBN(channel, way, 4412);
//			set_badPBN(channel, way, 4413);
//			set_badPBN(channel, way, 4414);
//			set_badPBN(channel, way, 4415);
//			set_badPBN(channel, way, 4416);
//			set_badPBN(channel, way, 4417);
//			set_badPBN(channel, way, 4418);
//			set_badPBN(channel, way, 4419);
//			set_badPBN(channel, way, 4420);
//			set_badPBN(channel, way, 4421);
//			set_badPBN(channel, way, 4422);
//			set_badPBN(channel, way, 4423);
//			set_badPBN(channel, way, 4424);
//			set_badPBN(channel, way, 4425);
//			set_badPBN(channel, way, 4426);
//			set_badPBN(channel, way, 4427);
//			set_badPBN(channel, way, 4428);
//			set_badPBN(channel, way, 4429);
//			set_badPBN(channel, way, 4430);
//			set_badPBN(channel, way, 4431);
//			set_badPBN(channel, way, 4432);
//			set_badPBN(channel, way, 4433);
//			set_badPBN(channel, way, 4434);
//			set_badPBN(channel, way, 4435);
//			set_badPBN(channel, way, 4436);
//			set_badPBN(channel, way, 4437);
//			set_badPBN(channel, way, 4438);
//			set_badPBN(channel, way, 4439);
//			set_badPBN(channel, way, 4440);
//			set_badPBN(channel, way, 4441);
//			set_badPBN(channel, way, 4442);
//			set_badPBN(channel, way, 4443);
//			set_badPBN(channel, way, 4444);
//			set_badPBN(channel, way, 4445);
//			set_badPBN(channel, way, 4446);
//			set_badPBN(channel, way, 4447);
//
//		}
//	}
//#endif
//}
//
//void FIL_Run(void)
//{
//	if (FIL_IsIdle() == TRUE)
//	{
//		return;
//	}
//
//	// not implemented yet!
//	FIL_ProcessDoneQ();
//	FIL_ProcessIssuedQ();
//	FIL_ProcessWaitQ();
//}
//
///*
//	@brief check a block is bad or not.
//			channel and way does not considered in current implementation.
//			the reason is FTL uses VBlock, which is super block.
//*/
//BOOL FIL_IsBad(INT32 channel, INT32 way, INT32 nPBN)
//{
//	// Bad block of cosmos+
//	static int anBadPBN2[] =
//	{
//		2300, 2312, 2327, 2336, 2368, 2379, 2386, 2399,
//		2135, 2136, 2138, 2147, 2162, 2172, 2255, 2259, 2270, 2271, 2275, 2283, 2285,
//		1920, 1927, 1937, 1964, 1990, 2008, 2009, 2037, 2051, 2095, 2111, 2113,
//		1728, 1739, 1747, 1765, 1790, 1798, 1814, 1841, 1859, 1881, 1895,
//		1626, 1629, 1650, 1663, 1685, 1695, 1704, 1708, 1711, 1715,
//		1332, 1344, 1348, 1355, 1380, 1388, 1391, 1395, 1481, 1529, 1539, 1566, 1613, 1625, 1990,
//		1161, 1204, 1205, 1209, 1211, 1225, 1231, 1241, 1242, 1277, 1283, 1311,
//		424, 429, 521, 543, 594, 629, 640, 909, 1095, 1098, 1101, 1113,
//		928, 566, 564, 562, 256, 320, 330, 415, 481, 505, 517, 527 ,565, 579, 585, 685, 699,
//		712, 714, 723, 735, 770, 776, 777, 801, 811, 818, 844 ,849, 886, 919, 927, 935, 949,
//		952, 974, 983, 997, 1017, 1019, 1033, 1049, 1054, 1064, 1099, 1147, 1157, 1183, 1190,
//		1195, 1232, 1250, 1263, 1287, 1330, 1334, 13335, 1343, 1354, 1357, 1363, 1370, 1374,
//		1386, 1400, 1407, 1423, 1443, 1457, 1540, 1569, 1580, 1596, 1597, 1602, 1614, 1651,
//		1658, 1659, 1664, 1670, 1674, 1675, 1679, 1694, 1710, 1714, 1754, 1762, 1813, 1815,
//		1822, 1828, 1842, 1845, 1852, 1862, 1897, 1899, 1925, 1933, 1936, 1946, 1950, 1991,
//		2027, 2032, 2038, 2047, 2060, 2072, 2080, 2094, 2116, 2120, 2121, 2123, 2169, 2177, 2185,
//		2187, 2203, 2209, 2212, 2211, 2221, 2229, 2238, 2265, 2307, 2309, 2314, 2319, 2350, 2359, 2384,
//		2388, 2389, 2397, 849, 1263, 2094, 1263, 2094, 949, 1330, 1580, 1670, 935, 1064, 1549, 1259,
//		1335, 1206, 1221, 1223, 1229, 1255, 1257, 1273, 1310, 1316, 1317, 1319, 1336, 1358, 1364,
//		1369, 1389, 1394, 1424, 1449, 1453, 1455, 1467, 1482, 1489, 1500, 1501, 1532, 1534, 1552,
//		1565, 1590, 1608, 1610, 1638, 1642, 1666, 1698, 1702, 1752, 1768, 1776, 1795, 1810, 1820,
//		1824, 1824, 1848, 1856, 1866, 1870, 1880, 1885, 1892, 1894, 1900, 1902, 1926, 1940, 1942, 1961,
//		1972, 1996, 2004, 2012, 2029, 2035, 2054, 2058, 2067, 2077, 2086, 2110, 2114, 2118, 2152,
//		2155, 2164, 2173, 2179, 1825, 2220, 2405, 2407, 2408, 2438, 2446, 2455, 2456, 2457, 2459, 2468,
//		2484, 2491, 2490, 2500, 2509, 2532, 2535, 2540, 2543, 2551, 2550, 2557, 2600, 2603, 2604, 2616, 2617,
//	};
//	for (int i = 0; i < sizeof(anBadPBN2) / sizeof(int); i++)
//	{
//		if (anBadPBN2[i] == nPBN)
//		{
//			break;
//		}
//	}
//
//	UINT32 offset = nPBN >> 3;
//	UINT32 offset_in_byte = nPBN % 8;
//	if (anBadPBN[channel][way][offset] & (1 << offset_in_byte))
//	{
//		return TRUE;
//	}
//
//
//	return FALSE;
//}
//
//BOOL FIL_IsEmpty_way(INT32 channel, INT32 way)
//{
//	return _FIL_IsEmptyWay(channel, way);
//}
//
///*
//	@brief	COSMOS+ does not support partial page read
//*/
//void FIL_ReadPage(FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
//{
//#ifdef SUPPORT_DATA_VERIFICATION
//	#ifdef WIN32
//		OSAL_MEMSET(pMainBuf, 0xFF, (sizeof(INT32) * 4/*LPN_PER_PHYSICAL_PAGE*/));
//	#endif
//		OSAL_MEMSET(pSpareBuf, 0xFF, (sizeof(INT32) * 4 /*LPN_PER_PHYSICAL_PAGE*/));
//#endif
//
//	_AddToWaitQ(FTL_REQUEST_READ, stReqID, stPhyAddr, pMainBuf, pSpareBuf);
//}
//
//void FIL_ProgramPage(FTL_REQUEST_ID	stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
//{
//	_AddToWaitQ(FTL_REQUEST_PROGRAM, stReqID, stPhyAddr, pMainBuf, pSpareBuf);
//}
//
//void FIL_EraseBlock(FTL_REQUEST_ID	stReqID, NAND_ADDR stPhyAddr)
//{
//	_AddToWaitQ(FTL_REQUEST_ERASE, stReqID, stPhyAddr, NULL, NULL);
//}
//
//int FIL_GetPagesPerBlock(void)
//{
//	int nPagesPerBlock;
//
//	if (BITS_PER_CELL == 1)
//	{
//		nPagesPerBlock = PAGES_PER_SLC_BLOCK;
//	}
//	else if (BITS_PER_CELL == 2)
//	{
//		nPagesPerBlock = PAGES_PER_MLC_BLOCK;
//	}
//	else
//	{
//		ASSERT(0);	// not supported
//		nPagesPerBlock = 0;
//	}
//
//	return nPagesPerBlock;
//}
//
//static void _AddToWaitQ(FTL_REQUEST_TYPE nReqType, FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
//{
//#if defined(_DEBUG) && defined(STREAM_FTL)
//	DEBUG_ASSERT(stReqID.stCommon.nType < FTL_REQUEST_ID_TYPE_COUNT);
//	switch (stReqID.stCommon.nType)
//	{
//		case FTL_REQUEST_ID_TYPE_PROGRAM:
//			// In this context FIL does not know what sub-type of write, (sub type must be one of HIL Write, GC Write, StreamMerge Write)
//			break;
//
//		case FTL_REQUEST_ID_TYPE_HIL_READ:
//		case FTL_REQUEST_ID_TYPE_STREAM_MERGE_READ:
//		case FTL_REQUEST_ID_TYPE_BLOCK_GC_READ:
//			break;
//
//		default:
//			ASSERT(0);		// Invalid type for NAND IO
//			break;
//	}
//
//	DEBUG_ASSERT(pMainBuf);
//	DEBUG_ASSERT(pSpareBuf);
//#endif
//
//	// Allocate Request
//	FTL_REQUEST*	pstRequest;
//	pstRequest = FIL_AllocateRequest();
//
//	DEBUG_ASSERT(pstRequest->nStatus == FTL_REQUEST_FREE);
//
//	pstRequest->stRequestID = stReqID;
//	pstRequest->nType = nReqType;
//	pstRequest->stAddr = stPhyAddr;
//	pstRequest->stBuf.pMainBuf = pMainBuf;
//	pstRequest->stBuf.pSpareBuf = pSpareBuf;
//
//	switch (nReqType)
//	{
//	case FTL_REQUEST_READ:
//		pstRequest->nStatus = FTL_REQUEST_READ_WAIT;
//		break;
//
//	case FTL_REQUEST_PROGRAM:
//		if (stPhyAddr.nPPage == 0)
//		{
//			pstRequest->nStatus = FTL_REQUEST_ERASE_FOR_PROGRAM_WAIT;
//		}
//		else
//		{
//			pstRequest->nStatus = FTL_REQUEST_PROGRAM_WAIT;
//		}
//		break;
//
//	case FTL_REQUEST_ERASE:
//		pstRequest->nStatus = FTL_REQUEST_ERASE_WAIT;
//		break;
//	}
//
//	// Add to waitQ
//	FIL_AddToRequestWaitQ(pstRequest, FALSE);
//
//}


/*******************************************************
*
* Copyright (C) 2018-2019
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
*
* This file is part of ESLab's Flash memory firmware
*
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/
#include "assert.h"
#include "xil_types.h"
#include "debug.h"

#include "cosmos_plus_system.h"
#include "cosmos_plus_memory_map.h"

#ifdef GREEDY_FTL
#include "request_schedule.h"
#endif

#include "cosmos_plus_system.h"

#include "fil.h"
#include "fil_nand.h"
#include "../Target/osal.h"
#include "fil_request.h"

static void _AddToWaitQ(FTL_REQUEST_TYPE nReqType, FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf);
static BOOL anBadPBN[USER_CHANNELS][USER_WAYS][TOTAL_BLOCKS_PER_DIE / 8];

void set_badPBN(UINT32 channel, UINT32 way, UINT32 pblk)
{
	UINT32 offset = pblk >> 3;
	UINT32 offset_in_byte = pblk % 8;

	anBadPBN[channel][way][offset] |= 1 << offset_in_byte;

}
void FIL_Initialize(void)
{
	NAND_Initialize();
	FIL_InitRequest();
	memset(&anBadPBN[0][0][0], 0, USER_CHANNELS * USER_WAYS * TOTAL_BLOCKS_PER_DIE / 8);

#ifndef WIN32
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++)
		{
			set_badPBN(channel, way, 353);
			set_badPBN(channel, way, 706);
			set_badPBN(channel, way, 736);
			set_badPBN(channel, way, 1012);
			set_badPBN(channel, way, 1114);
			set_badPBN(channel, way, 1219);
			set_badPBN(channel, way, 1313);
			set_badPBN(channel, way, 1325);
			set_badPBN(channel, way, 1404);
			set_badPBN(channel, way, 1469);
			set_badPBN(channel, way, 1493);
			set_badPBN(channel, way, 1722);
			set_badPBN(channel, way, 1761);
			set_badPBN(channel, way, 1801);
			set_badPBN(channel, way, 1831);
			set_badPBN(channel, way, 1847);
			set_badPBN(channel, way, 1968);
			set_badPBN(channel, way, 1996);
			set_badPBN(channel, way, 1998);
			set_badPBN(channel, way, 2004);
			set_badPBN(channel, way, 2157);
			set_badPBN(channel, way, 2179);
			set_badPBN(channel, way, 2181);
			set_badPBN(channel, way, 2225);
			set_badPBN(channel, way, 2259);
			set_badPBN(channel, way, 2283);
			set_badPBN(channel, way, 2327);
			set_badPBN(channel, way, 2387);
			set_badPBN(channel, way, 2414);
			set_badPBN(channel, way, 2467);
			set_badPBN(channel, way, 2480);
			set_badPBN(channel, way, 2496);
			set_badPBN(channel, way, 2520);
			set_badPBN(channel, way, 2593);
			set_badPBN(channel, way, 2608);
			set_badPBN(channel, way, 2610);
			set_badPBN(channel, way, 2634);
			set_badPBN(channel, way, 2753);
			set_badPBN(channel, way, 2842);
			set_badPBN(channel, way, 2852);
			set_badPBN(channel, way, 2871);
			set_badPBN(channel, way, 2894);
			set_badPBN(channel, way, 2978);
			set_badPBN(channel, way, 3051);
			set_badPBN(channel, way, 3055);
			set_badPBN(channel, way, 3111);
			set_badPBN(channel, way, 3156);
			set_badPBN(channel, way, 3157);
			set_badPBN(channel, way, 3203);
			set_badPBN(channel, way, 3226);
			set_badPBN(channel, way, 3328);
			set_badPBN(channel, way, 3342);
			set_badPBN(channel, way, 381);
			set_badPBN(channel, way, 3387);
			set_badPBN(channel, way, 3432);
			set_badPBN(channel, way, 3449);
			set_badPBN(channel, way, 3458);
			set_badPBN(channel, way, 3468);
			set_badPBN(channel, way, 3469);
			set_badPBN(channel, way, 3475);
			set_badPBN(channel, way, 3476);
			set_badPBN(channel, way, 3477);
			set_badPBN(channel, way, 3493);
			set_badPBN(channel, way, 3561);
			set_badPBN(channel, way, 3565);
			set_badPBN(channel, way, 3614);
			set_badPBN(channel, way, 3680);
			set_badPBN(channel, way, 3760);
			set_badPBN(channel, way, 3769);
			set_badPBN(channel, way, 3834);
			set_badPBN(channel, way, 3885);
			set_badPBN(channel, way, 3900);
			set_badPBN(channel, way, 3988);
			set_badPBN(channel, way, 4057);
			set_badPBN(channel, way, 4064);
			set_badPBN(channel, way, 4089);
			set_badPBN(channel, way, 4161);
			for (int i = 4184; i <= 4447; i++) {
				set_badPBN(channel, way, i);
			}
		}
	}
#endif
}

void FIL_Run(void)
{
	if (FIL_IsIdle() == TRUE)
	{
		return;
	}

	// not implemented yet!
	FIL_ProcessDoneQ();
	FIL_ProcessIssuedQ();
	FIL_ProcessWaitQ();
}

/*
	@brief check a block is bad or not.
			channel and way does not considered in current implementation.
			the reason is FTL uses VBlock, which is super block.
*/
BOOL FIL_IsBad(INT32 channel, INT32 way, INT32 nPBN)
{
	static int anBadPBN2[] =
	{ -1 };

	UINT32 offset = nPBN >> 3;
	UINT32 offset_in_byte = nPBN % 8;
	if (anBadPBN[channel][way][offset] & (1 << offset_in_byte))
	{
		return TRUE;
	}


	return FALSE;
}

BOOL FIL_IsEmpty_way(INT32 channel, INT32 way)
{
	return _FIL_IsEmptyWay(channel, way);
}

/*
	@brief	COSMOS+ does not support partial page read
*/
void FIL_ReadPage(FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
{
#ifdef SUPPORT_DATA_VERIFICATION
	#ifdef WIN32
		OSAL_MEMSET(pMainBuf, 0xFF, (sizeof(INT32) * 4/*LPN_PER_PHYSICAL_PAGE*/));
	#endif
		OSAL_MEMSET(pSpareBuf, 0xFF, (sizeof(INT32) * 4 /*LPN_PER_PHYSICAL_PAGE*/));
#endif

	_AddToWaitQ(FTL_REQUEST_READ, stReqID, stPhyAddr, pMainBuf, pSpareBuf);
}

void FIL_ProgramPage(FTL_REQUEST_ID	stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
{
	_AddToWaitQ(FTL_REQUEST_PROGRAM, stReqID, stPhyAddr, pMainBuf, pSpareBuf);
}

void FIL_EraseBlock(FTL_REQUEST_ID	stReqID, NAND_ADDR stPhyAddr)
{
	_AddToWaitQ(FTL_REQUEST_ERASE, stReqID, stPhyAddr, NULL, NULL);
}

int FIL_GetPagesPerBlock(void)
{
	int nPagesPerBlock;

	if (BITS_PER_CELL == 1)
	{
		nPagesPerBlock = PAGES_PER_SLC_BLOCK;
	}
	else if (BITS_PER_CELL == 2)
	{
		nPagesPerBlock = PAGES_PER_MLC_BLOCK;
	}
	else
	{
		ASSERT(0);	// not supported
		nPagesPerBlock = 0;
	}

	return nPagesPerBlock;
}

static void _AddToWaitQ(FTL_REQUEST_TYPE nReqType, FTL_REQUEST_ID stReqID, NAND_ADDR stPhyAddr, void* pMainBuf, void* pSpareBuf)
{
#if defined(_DEBUG) && defined(STREAM_FTL)
	DEBUG_ASSERT(stReqID.stCommon.nType < FTL_REQUEST_ID_TYPE_COUNT);
	switch (stReqID.stCommon.nType)
	{
		case FTL_REQUEST_ID_TYPE_PROGRAM:
			// In this context FIL does not know what sub-type of write, (sub type must be one of HIL Write, GC Write, StreamMerge Write)
			break;

		case FTL_REQUEST_ID_TYPE_HIL_READ:
		case FTL_REQUEST_ID_TYPE_STREAM_MERGE_READ:
		case FTL_REQUEST_ID_TYPE_BLOCK_GC_READ:
			break;

		default:
			ASSERT(0);		// Invalid type for NAND IO
			break;
	}

	DEBUG_ASSERT(pMainBuf);
	DEBUG_ASSERT(pSpareBuf);
#endif

	// Allocate Request
	FTL_REQUEST*	pstRequest;
	pstRequest = FIL_AllocateRequest();

	DEBUG_ASSERT(pstRequest->nStatus == FTL_REQUEST_FREE);

	pstRequest->stRequestID = stReqID;
	pstRequest->nType = nReqType;
	pstRequest->stAddr = stPhyAddr;
	pstRequest->stBuf.pMainBuf = pMainBuf;
	pstRequest->stBuf.pSpareBuf = pSpareBuf;

	switch (nReqType)
	{
	case FTL_REQUEST_READ:
		pstRequest->nStatus = FTL_REQUEST_READ_WAIT;
		break;

	case FTL_REQUEST_PROGRAM:
		if (stPhyAddr.nPPage == 0)
		{
			pstRequest->nStatus = FTL_REQUEST_ERASE_FOR_PROGRAM_WAIT;
		}
		else
		{
			pstRequest->nStatus = FTL_REQUEST_PROGRAM_WAIT;
		}
		break;

	case FTL_REQUEST_ERASE:
		pstRequest->nStatus = FTL_REQUEST_ERASE_WAIT;
		break;
	}

	// Add to waitQ
	FIL_AddToRequestWaitQ(pstRequest, FALSE);

}
