/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "dftl_internal.h"

VOID
SUPER_GC_MGR::Initialize(VOID)
{
	m_nThreshold	= DFTL_GLOBAL::GetGCMgr(0,0)->m_nThreshold;
	m_nVictimVBN 	= INVALID_VBN;
	m_nGCCnt 		= 0;
}

BOOL
SUPER_GC_MGR::IsGCRunning(VOID)
{
	if (m_nVictimVBN == INVALID_VBN)
		return 0;
	else
		return 1;
}

UINT32
SUPER_GC_MGR::GetVictimVBN(VOID)
{
    SBINFO_MGR* pSBMgr   = DFTL_GLOBAL::GetSBInfoMgr();
    VNAND*      pVNAND   = DFTL_GLOBAL::GetVNandMgr();
    UINT32      vblk_cnt = DFTL_GLOBAL::GetInstance()->m_nVBlockCount;

    UINT32 best_vbn = INVALID_VBN;
    UINT32 best_vpc = pVNAND->GetVPagesPerVBlock() * (USER_CHANNELS * USER_WAYS);

    int meta = 0;
    int bad = 0;
    int free = 0;

    for (UINT32 vbn = 20; vbn < vblk_cnt; ++vbn)
    {
        SBINFO& sb = pSBMgr->m_pastSBInfo[vbn];

        if ((sb.IsMeta() == TRUE) || (sb.IsBad() == TRUE) || (sb.IsFree() == TRUE)) {
        	if (sb.IsMeta() == TRUE)
        		meta++;
        	if (sb.IsBad() == TRUE)
        		bad++;
        	if (sb.IsFree() == TRUE)
        		free++;
            continue;
        }
        UINT32 sb_vpc_total = 0;

        for (UINT32 ch = 0; ch < USER_CHANNELS; ++ch)
        {
            for (UINT32 wy = 0; wy < USER_WAYS; ++wy)
            {
            	UINT32  invalid;
            	UINT32 	valid;
                VBINFO* vbi   = DFTL_GLOBAL::GetVBInfoMgr(ch, wy)->GetVBInfo(vbn);
                if (vbi->IsFree())
                	valid = 0;
                else
                {
                	invalid = vbi->GetInvalidLPNCount();
                	valid = pVNAND->GetVPagesPerVBlock() - invalid;
                }
                sb_vpc_total += valid;
            }
        }

        if (sb_vpc_total < best_vpc) {
            best_vpc = sb_vpc_total;
            best_vbn = vbn;
        }
    }

    if(best_vbn == INVALID_VBN) {
    	xil_printf("FREE:%u, META:%u, BAD:%u\n", free, meta, bad);
    }
    return best_vbn;
}


BOOL
SUPER_GC_MGR::CheckAndStartGC()
{
	if (DFTL_GLOBAL::GetInstance()->SB_INIT_FLAG == FALSE)
		return 0;

	if (IsGCRunning() == TRUE)
	{
		return 0;
	}

	UINT32 nFreeBlock;

	DFTL_GLOBAL*	pstGlobal = DFTL_GLOBAL::GetInstance();

	nFreeBlock = pstGlobal->GetSBInfoMgr()->m_nFreeCount;

	if (nFreeBlock > m_nThreshold)
	{
		return 0;
	}

	UINT32 CandVBN = GetVictimVBN();
	if (CandVBN != INVALID_VBN)
	{
		m_nVictimVBN = CandVBN;
		xil_printf("GC START [%u] %u\r\n", m_nVictimVBN, nFreeBlock);
		UINT32 vic_cid = pstGlobal->GetSBInfoMgr()->m_pastSBInfo[CandVBN].m_bCID;
//		xil_printf("[GC START] VBN:%u CLUSTER:%u\r\n", CandVBN, vic_cid);

		UINT32 min_cid = 0u;
		UINT32 min_pct = 101u;

		for (UINT32 i = 0; i < (UINT32)USER_CLUSTERS; ++i) {
		    const UINT32 PAGES_PER_SB = 2048u;
		    INT32 sb = DFTL_GLOBAL::GetInstance()->m_util_blks[i];
		    INT32 vp = DFTL_GLOBAL::GetInstance()->m_util_pages[i];
		    UINT32 pct = (sb > 0 && vp > 0) ? ((UINT32)vp * 100u) / ((UINT32)sb * PAGES_PER_SB) : 0u;
//		    xil_printf("  [C%u] SB:%d VP:%d VP/SB(%%):%u\r\n", i, sb, vp, pct);
		    if (pct < min_pct) {
		        min_pct = pct;
		        min_cid = i;
		    }
		}

		const UINT32 PAGES_PER_SB = 2048u;
		INT32  vic_sb  = DFTL_GLOBAL::GetInstance()->m_util_blks[vic_cid];
		INT32  vic_vp  = DFTL_GLOBAL::GetInstance()->m_util_pages[vic_cid];
		UINT32 vic_pct = (vic_sb > 0 && vic_vp > 0) ? ((UINT32)vic_vp * 100u) / ((UINT32)vic_sb * PAGES_PER_SB) : 0u;

		if (vic_pct == min_pct) {
			DFTL_GLOBAL::GetInstance()->hit++;
			DFTL_IncreaseProfile(Prof_GC_UTIL_Hit);
//			xil_printf("  => MATCH: victim cluster %u pct=%u%% == min_pct=%u%% (min_cid=%u)\r\n",
//					vic_cid, vic_pct, min_pct, min_cid);
		} else {
			DFTL_GLOBAL::GetInstance()->miss++;
			DFTL_IncreaseProfile(Prof_GC_UTIL_Miss);
//			xil_printf("  => MISMATCH: victim cluster %u pct=%u%% != min_pct=%u%% (min_cid=%u)\r\n",
//					vic_cid, vic_pct, min_pct, min_cid);
		}

		return 1;
	}
	else
	{
		xil_printf("GC NO VICTIM WRONG [%u]\r\n", nFreeBlock);
		return 0;
	}
}

VOID 
GC_MGR::Initialize(UINT32 nGCTh, IOTYPE eIOType, UINT32 channel, UINT32 way)
{
	m_nThreshold	= nGCTh;
	m_eIOType		= eIOType;
	m_channel = channel;
	m_way = way;
	m_nVictimVBN = INVALID_VBN;
	GC_POLICY_GREEDY::Initialize(eIOType);
}

VOID
GC_MGR::Run(VOID)
{
	if (IsGCRunning() == FALSE)
	{
		// nothing to do
		return;
	}

#if (SUPPORT_META_DEMAND_LOADING == 1)
	if (m_eIOType == IOTYPE_GC)
	{
		// Check MetaGC
		if (DFTL_GLOBAL::GetInstance()->isMetaGCing() == TRUE)
		{
			return;
		}
	}
#endif

	_Read();
}

BOOL
GC_MGR::IsGCRunning(VOID)
{
	if (m_nVictimVBN == INVALID_VBN)
	{
		return FALSE;
	}

	return TRUE;
}

VOID
GC_MGR::CheckAndStartGC(VOID)
{
	// check is there anys running GC
	if (m_eIOType == IOTYPE_META)
	{
		if (IsGCRunning() == TRUE)
		{
			return;
		}
	}

	UINT32 nFreeBlock;

	DFTL_GLOBAL*	pstGlobal = DFTL_GLOBAL::GetInstance();

	nFreeBlock = m_pstBlockMgr->GetFreeBlockCount(m_channel, m_way);

	if (m_eIOType == IOTYPE_META)
	{
		if (nFreeBlock > m_nThreshold)
		{
			// enough free block
			return;
		}
	}

	if (m_eIOType == IOTYPE_META)
	{
		m_nVictimVBN = GetVictimVBN(m_channel, m_way);
	}
	else
	{
		UINT32 cand_victim = pstGlobal->GetSuperGCMgr()->m_nVictimVBN;
		if (DFTL_GLOBAL::GetVBInfoMgr(m_channel, m_way)->GetVBInfo(cand_victim)->IsFree())
			return;
		pstGlobal->GetSuperGCMgr()->m_nGCCnt += 1;
		m_nVictimVBN = cand_victim;
	}

	m_nVPC = pstGlobal->GetVPagePerVBlock() - DFTL_GLOBAL::GetVBInfoMgr(m_channel, m_way)->GetVBInfo(m_nVictimVBN)->GetInvalidLPNCount();
	m_nVCNT = DFTL_GLOBAL::GetVBInfoMgr(m_channel, m_way)->GetVBInfo(m_nVictimVBN)->GetValidLPNCount();
	m_nCurReadVPageOffset = 0;
	m_nWriteCount = 0;
	m_nIssuedCount = 0;

	if (m_eIOType == IOTYPE_META) {
		DFTL_GLOBAL::GetInstance()->SetMetaGCing();
		DFTL_IncreaseProfile(Prof_CMTGC_count);
	}
	else {
		DFTL_IncreaseProfile(Prof_GC_count);
	}

#if (SUPPORT_GC_DEBUG == 1)
	m_stDebug.Initialize();
#endif

#if (SUPPORT_BLOCK_DEBUG == 1)
	m_pstBlockMgr->CheckVPC(m_channel, m_way, m_nVictimVBN);
#endif
}

VOID
GC_MGR::IncreaseWriteCount(VOID)
{
	m_nWriteCount++;

	if (m_eIOType == IOTYPE_META) {
		DFTL_IncreaseProfile(Prof_CMTGC_write);
	}
	else {
		DFTL_IncreaseProfile(Prof_GC_write);
	}

	DEBUG_ASSERT(m_nWriteCount <= m_nVPC);

	if (m_nWriteCount == m_nVPC)
	{
		UINT32 pastVBN = m_nVictimVBN;
		m_nVictimVBN = INVALID_VBN;
#if (SUPPORT_META_DEMAND_LOADING == 1)
		if (m_eIOType == IOTYPE_META) {
			BOOL	Meta_GCing = FALSE;
			for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
				for (UINT32 way = 0; way < USER_WAYS; way++) {
					if (DFTL_GLOBAL::GetMetaGCMgr(channel, way)->IsGCRunning() == TRUE) {
						Meta_GCing = TRUE;
					}
				}
			}
			if(Meta_GCing == FALSE)
				DFTL_GLOBAL::GetInstance()->ClearMetaGCing();
		}
		else
		{
			if (DFTL_GLOBAL::GetVBInfoMgr(m_channel, m_way)->GetVBInfo(pastVBN)->IsFree() != TRUE)
			{
				DFTL_GLOBAL::GetInstance()->GetUserBlockMgr()->Release(m_channel, m_way, pastVBN, 2);
			}

			DFTL_GLOBAL::GetSuperGCMgr()->m_nGCCnt -= 1;
			if (DFTL_GLOBAL::GetSuperGCMgr()->m_nGCCnt == 0)
			{
				xil_printf("[GC END'1] VBN:%u(%d USED), FREE:%u\r\n",  pastVBN,
						   DFTL_GLOBAL::GetSBInfoMgr()->m_pastSBInfo[pastVBN].m_nUSED,
						   DFTL_GLOBAL::GetSBInfoMgr()->m_nFreeCount);
				DFTL_GLOBAL::GetSuperGCMgr()->m_nVictimVBN = INVALID_VBN;
			}
		}
#endif
	}
}

VOID
GC_MGR::IncreaseIssuedCount(VOID)
{
	m_nIssuedCount++;

	DEBUG_ASSERT(m_nIssuedCount <= m_nVPC);
}

//VOID
//GC_MGR::_Read(VOID)
//{
//	DFTL_GLOBAL*	pstGlobal = DFTL_GLOBAL::GetInstance();
//	VNAND*			pstVNand = pstGlobal->GetVNandMgr();
//	if (m_nIssuedCount != m_nWriteCount && m_nIssuedCount != m_nWriteCount + 1) {
//		return;
//	}
//	do
//	{
//		if (m_nCurReadVPageOffset >= pstGlobal->GetVPagePerVBlock())
//		{
//			if (m_eIOType != IOTYPE_META)
//			{
//				if (m_nWriteCount == m_nIssuedCount)
//				{
//					if (DFTL_GLOBAL::GetVBInfoMgr(m_channel, m_way)->GetVBInfo(m_nVictimVBN)->IsFree() != TRUE)
//					{
//						DFTL_GLOBAL::GetInstance()->GetUserBlockMgr()->Release(m_channel, m_way, m_nVictimVBN, 3);
//					}
//
//					DFTL_GLOBAL::GetSuperGCMgr()->m_nGCCnt -= 1;
//					if (DFTL_GLOBAL::GetSuperGCMgr()->m_nGCCnt == 0)
//					{
//					    xil_printf("[GC END'2] VBN:%u(%d USED), FREE:%u\r\n", m_nVictimVBN,
//								DFTL_GLOBAL::GetSBInfoMgr()->m_pastSBInfo[m_nVictimVBN].m_nUSED,
//								DFTL_GLOBAL::GetSBInfoMgr()->m_nFreeCount);
//						DFTL_GLOBAL::GetSuperGCMgr()->m_nVictimVBN = INVALID_VBN;
//					}
//					m_nVictimVBN = INVALID_VBN;
//				}
//				else
//				{
//					if (m_nVPC != m_nIssuedCount)
//					{
//						m_nVPC = m_nIssuedCount;
//					}
//				}
//			}
//			return;
//		}
//
//		BOOL bValid = pstVNand->IsValid(m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset);
//		if (bValid == TRUE)
//		{
//			break;
//		}
//		m_nCurReadVPageOffset++;
//
//		DEBUG_ASSERT(m_nCurReadVPageOffset <= pstGlobal->GetVPagePerVBlock());
//	} while (1);
//
//	REQUEST_MGR*	pstReqMgr = pstGlobal->GetRequestMgr();
//
//	// Issue Read
//	GC_REQUEST*	pstRequest;
//
//	pstRequest = pstReqMgr->AllocateGCRequest();
//	if (pstRequest == NULL)
//	{
//		// no more free request
//		return;
//	}
//
//	UINT32	nVPPN = VPPN_FROM_VBN_VPN(m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset);
//
//	pstRequest->Initialize(GC_REQUEST_READ_WAIT, nVPPN, m_eIOType);
//
//	pstReqMgr->AddToGCRequestWaitQ(pstRequest);
//
//	m_nCurReadVPageOffset++;
//	IncreaseIssuedCount();
//
//	if (m_nCurReadVPageOffset >= pstGlobal->GetVPagePerVBlock())
//		if (m_eIOType != IOTYPE_META)
//			m_nVPC = m_nIssuedCount;
//
//	if (m_eIOType == IOTYPE_META) {
//		DFTL_IncreaseProfile(Prof_CMTGC_read);
//	}
//	else {
//		DFTL_IncreaseProfile(Prof_GC_read);
//	}
//	return;
//}
VOID
GC_MGR::_Read(VOID)
{
    DFTL_GLOBAL* pstGlobal = DFTL_GLOBAL::GetInstance();
    VNAND*       pstVNand  = pstGlobal->GetVNandMgr();

    // Victim 없으면 할 일 없음
    if (m_nVictimVBN == INVALID_VBN) {
        return;
    }

    const UINT32 vppb = pstGlobal->GetVPagePerVBlock();
    const bool   isUserGC = (m_eIOType != IOTYPE_META);

    // ------------------------------------------------------------
    // Debug state: 채널/웨이별로 분리 (static 섞임 방지)
    // ------------------------------------------------------------
    struct ReadDbgState {
        bool   init;
        UINT32 lastIssued;
        UINT32 lastWrite;
        UINT32 lastOff;
        UINT32 lastVBN;
        UINT32 lastIO;

        unsigned stallCtr;
        unsigned gateCtr;
        unsigned endWaitCtr;
        unsigned allocFailCtr;
    };

    static ReadDbgState s_dbg[USER_CHANNELS][USER_WAYS]; // USER_CHANNELS/USER_WAYS가 이미 존재한다고 가정
    ReadDbgState& dbg = s_dbg[m_channel][m_way];

    if (!dbg.init) {
        dbg.init       = true;
        dbg.lastIssued = 0xFFFFFFFF;
        dbg.lastWrite  = 0xFFFFFFFF;
        dbg.lastOff    = 0xFFFFFFFF;
        dbg.lastVBN    = 0xFFFFFFFF;
        dbg.lastIO     = 0xFFFFFFFF;
        dbg.stallCtr   = 0;
        dbg.gateCtr    = 0;
        dbg.endWaitCtr = 0;
        dbg.allocFailCtr = 0;
    }

    auto isPow2 = [](unsigned x) -> bool {
        return (x != 0) && ((x & (x - 1)) == 0);
    };

    // ------------------------------------------------------------
    // [LOG#0] STALL 감지 (USER GC에서만)
    // ------------------------------------------------------------
    if (isUserGC)
    {
        if (dbg.lastIssued == m_nIssuedCount &&
            dbg.lastWrite  == m_nWriteCount &&
            dbg.lastOff    == m_nCurReadVPageOffset &&
            dbg.lastVBN    == m_nVictimVBN &&
            dbg.lastIO     == (UINT32)m_eIOType)
        {
            dbg.stallCtr++;
            if (isPow2(dbg.stallCtr)) {
                xil_printf("[GC][READ] STALL (pow2) ch=%u wy=%u VBN=%u off=%u issued=%u write=%u io=%u\r\n",
                           m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset,
                           m_nIssuedCount, m_nWriteCount, (unsigned)m_eIOType);
            }
        }
        else
        {
            dbg.stallCtr   = 0;
            dbg.lastIssued = m_nIssuedCount;
            dbg.lastWrite  = m_nWriteCount;
            dbg.lastOff    = m_nCurReadVPageOffset;
            dbg.lastVBN    = m_nVictimVBN;
            dbg.lastIO     = (UINT32)m_eIOType;
        }
    }

    // ------------------------------------------------------------
    // [LOG#1] READ 게이트: issued == write 또는 write+1 만 허용
    // ------------------------------------------------------------
    if (m_nIssuedCount != m_nWriteCount &&
        m_nIssuedCount != (m_nWriteCount + 1))
    {
        if (isUserGC) {
            dbg.gateCtr++;
            if (isPow2(dbg.gateCtr)) {
                xil_printf("[GC][READ] GATE (pow2) ch=%u wy=%u VBN=%u off=%u issued=%u write=%u io=%u\r\n",
                           m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset,
                           m_nIssuedCount, m_nWriteCount, (unsigned)m_eIOType);
            }
        }
        return;
    }

    // ------------------------------------------------------------
    // End-of-block 처리: 더 읽을 페이지가 없으면 종료/대기
    // ------------------------------------------------------------
    if (m_nCurReadVPageOffset >= vppb)
    {
        if (isUserGC)
        {
            if (m_nWriteCount == m_nIssuedCount)
            {
                // victim release
                if (DFTL_GLOBAL::GetVBInfoMgr(m_channel, m_way)
                        ->GetVBInfo(m_nVictimVBN)->IsFree() != TRUE)
                {
                    DFTL_GLOBAL::GetInstance()->GetUserBlockMgr()->Release(m_channel, m_way, m_nVictimVBN, 3);
                }

                DFTL_GLOBAL::GetSuperGCMgr()->m_nGCCnt -= 1;
                if (DFTL_GLOBAL::GetSuperGCMgr()->m_nGCCnt == 0)
                {
                    xil_printf("[GC END'2] VBN:%u(%d USED), FREE:%u\r\n", m_nVictimVBN,
                               DFTL_GLOBAL::GetSBInfoMgr()->m_pastSBInfo[m_nVictimVBN].m_nUSED,
                               DFTL_GLOBAL::GetSBInfoMgr()->m_nFreeCount);
                    DFTL_GLOBAL::GetSuperGCMgr()->m_nVictimVBN = INVALID_VBN;
                }

                m_nVictimVBN = INVALID_VBN;
            }
            else
            {
                // ------------------------------------------------------------
                // [LOG#2] END_WAIT (USER GC에서만)
                // ------------------------------------------------------------
                dbg.endWaitCtr++;
                if (isPow2(dbg.endWaitCtr)) {
                    xil_printf("[GC][READ] END_WAIT (pow2) ch=%u wy=%u VBN=%u issued=%u write=%u VPC=%u\r\n",
                               m_channel, m_way, m_nVictimVBN,
                               m_nIssuedCount, m_nWriteCount, m_nVPC);
                }

                if (m_nVPC != m_nIssuedCount) {
                    m_nVPC = m_nIssuedCount;
                }
            }
        }
        return;
    }

    // ------------------------------------------------------------
    // 다음 valid page 찾기
    // ------------------------------------------------------------
    while (m_nCurReadVPageOffset < vppb)
    {
        if (pstVNand->IsValid(m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset) == TRUE) {
            break;
        }
        m_nCurReadVPageOffset++;
    }

    // 끝까지 갔으면(유효 페이지 없음) end 처리로 다시 진입하게 리턴
    if (m_nCurReadVPageOffset >= vppb) {
        if (isUserGC) {
            // 마지막 issued를 기록해두는 기존 의도 유지
            m_nVPC = m_nIssuedCount;
        }
        return;
    }

    // ------------------------------------------------------------
    // Issue Read
    // ------------------------------------------------------------
    REQUEST_MGR* pstReqMgr = pstGlobal->GetRequestMgr();

    GC_REQUEST* pstRequest = pstReqMgr->AllocateGCRequest();
    if (pstRequest == NULL)
    {
        // ------------------------------------------------------------
        // [LOG#3] req pool 고갈 (USER GC에서만)
        // ------------------------------------------------------------
        if (isUserGC)
        {
            dbg.allocFailCtr++;
            if (isPow2(dbg.allocFailCtr)) {
                xil_printf("[GC][READ] ALLOC_GC_REQ FAIL (pow2) ch=%u wy=%u VBN=%u off=%u issued=%u write=%u io=%u\r\n",
                           m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset,
                           m_nIssuedCount, m_nWriteCount, (unsigned)m_eIOType);
            }
        }
        return;
    }

    const UINT32 nVPPN = VPPN_FROM_VBN_VPN(m_channel, m_way, m_nVictimVBN, m_nCurReadVPageOffset);

    pstRequest->Initialize(GC_REQUEST_READ_WAIT, nVPPN, m_eIOType);
    pstReqMgr->AddToGCRequestWaitQ(pstRequest);

    m_nCurReadVPageOffset++;
    IncreaseIssuedCount();

    if (m_nCurReadVPageOffset >= vppb && isUserGC) {
        m_nVPC = m_nIssuedCount;
    }

    if (m_eIOType == IOTYPE_META) {
        DFTL_IncreaseProfile(Prof_CMTGC_read);
    } else {
        DFTL_IncreaseProfile(Prof_GC_read);
    }
}



///////////////////////////////////////////////////////////////////////////////
//
//	GREEDY VICTIM SELECTION
//
///////////////////////////////////////////////////////////////////////////////

VOID 
GC_POLICY_GREEDY::Initialize(IOTYPE eIOType)
{
	switch (eIOType)
	{
	case IOTYPE_GC:
		m_pstBlockMgr = DFTL_GLOBAL::GetUserBlockMgr();
		break;

#if (SUPPORT_META_DEMAND_LOADING == 1)
	case IOTYPE_META:
		m_pstBlockMgr = DFTL_GLOBAL::GetMetaBlockMgr();
		break;
#endif

	default:
		ASSERT(0);
		break;
	}
}

/*
	@brief	choose a maximum invalid page block
			this function can be imrpoved an InvalidPageCount hash data structure
				to decrease MaxInvalidPageBlock lookup time
*/
UINT32
GC_POLICY_GREEDY::GetVictimVBN(UINT32 channel, UINT32 way)
{
	VBINFO*	pstVBInfo;
	UINT32	nVictimVBN = INVALID_VBN;
	UINT32	nMaxInvalid = 0;

	// lookup all used blocks
	// CHECKME, TBD, 성능 개선 필요.
	list_for_each_entry(VBINFO, pstVBInfo, &m_pstBlockMgr->m_dlUsedBlocks[channel][way], m_dlList)
	{
		DEBUG_ASSERT(pstVBInfo->IsFree() == FALSE);

		if (pstVBInfo->IsActive() == TRUE)
		{
			continue;
		}

		if (pstVBInfo->GetInvalidLPNCount() > nMaxInvalid)
		{
			nMaxInvalid	= pstVBInfo->GetInvalidLPNCount();
			nVictimVBN	= pstVBInfo->m_nVBN;
		}
	}

	DEBUG_ASSERT(nVictimVBN != INVALID_VBN);

	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_BGC);

	return nVictimVBN;
}


///////////////////////////////////////////////////////////////////////////////
//
//	DEBUGGING
//
///////////////////////////////////////////////////////////////////////////////

VOID
GC_DEBUG::Initialize(VOID)
{
	INT32 nSize;
	nSize = DFTL_GLOBAL::GetInstance()->GetVPagePerVBlock() * sizeof(GC_DEBUG_FLAG);

	if (m_apstVPNStatus == NULL)
	{
		m_apstVPNStatus = static_cast<GC_DEBUG_FLAG*>(OSAL_MemAlloc(MEM_TYPE_FW_DATA, nSize, OSAL_MEMALLOC_FW_ALIGNMENT));
	}

	OSAL_MEMSET(m_apstVPNStatus, 0x00, nSize);
	m_nRead = 0;
	m_nWrite = 0;
}

VOID
GC_DEBUG::SetFlag(UINT32 nVPPN, GC_DEBUG_FLAG eFlag)
{
	UINT32 modVPPN = CHANNEL_VPPN(nVPPN);
	UINT32 nVPageOffset = VPN_FROM_VPPN(modVPPN);
	UINT32 channel = CHANNEL_FROM_VPPN(nVPPN);
	UINT32 way = WAY_FROM_VPPN(nVPPN);

	DEBUG_ASSERT((m_apstVPNStatus[nVPageOffset] & eFlag) == 0);

	m_apstVPNStatus[nVPageOffset] = static_cast<GC_DEBUG_FLAG>((UINT32)m_apstVPNStatus[nVPageOffset] | (UINT32)eFlag);

	switch (eFlag)
	{
	case GC_DEBUG_FLAG_READ:
		m_nRead++;
		break;

	case GC_DEBUG_FLAG_WRITE_ISSUE:
		m_nWrite++;
		break;

	case GC_DEBUG_FLAG_WRITE_DONE:
		DEBUG_ASSERT(m_apstVPNStatus[nVPageOffset] == GC_DEBUG_FLAG_MASK);
		break;
	}
}
