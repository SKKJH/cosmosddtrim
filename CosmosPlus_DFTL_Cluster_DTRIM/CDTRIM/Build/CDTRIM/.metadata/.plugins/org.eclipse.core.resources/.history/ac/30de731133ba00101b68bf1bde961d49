/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "hil.h"

#include "dftl_internal.h"

DFTL_GLOBAL* DFTL_GLOBAL::m_pstInstance;

VOID DFTL_GLOBAL::WritePtr_GetAndAdvance(UINT32 clusterID)
{
    m_page_cnt[clusterID]++;
    if (m_page_cnt[clusterID] >= LPN_PER_PHYSICAL_PAGE) {
        m_page_cnt[clusterID] = 0;
        m_wp_ch[clusterID]++;
        if (m_wp_ch[clusterID] >= USER_CHANNELS) {
            m_wp_ch[clusterID] = 0;
            m_wp_wy[clusterID]++;
            if (m_wp_wy[clusterID] >= USER_WAYS) {
                m_wp_wy[clusterID] = 0;
            }
        }
    }
}

VOID DFTL_GLOBAL::GC_WritePtr_GetAndAdvance(UINT32 clusterID)
{
    m_gc_page_cnt[clusterID]++;
    if (m_gc_page_cnt[clusterID] >= LPN_PER_PHYSICAL_PAGE) {
        m_gc_page_cnt[clusterID] = 0;
        m_gc_wp_ch[clusterID]++;
        if (m_gc_wp_ch[clusterID] >= USER_CHANNELS) {
            m_gc_wp_ch[clusterID] = 0;
            m_gc_wp_wy[clusterID]++;
            if (m_gc_wp_wy[clusterID] >= USER_WAYS) {
                m_gc_wp_wy[clusterID] = 0;
            }
        }
    }
}

VOID DFTL_GLOBAL::DebugBlockPrint(UINT32 FLAG)
{
    GetUserBlockMgr()->DebugPrintAllByVBN(FLAG);
}

UINT32 DFTL_GLOBAL::GetClusterID(UINT32 LPN)
{
    UINT64 num   = (UINT64)LPN * (UINT64)USER_CLUSTERS;
    UINT32 cid   = (UINT32)(num / (UINT64)m_nLPNCount);

    if (cid >= USER_CLUSTERS)
    {
    	xil_printf("Wrong CID\r\n");
    	assert(0);
    }

//    xil_printf("	[MAKE] LPN:%u, CLUSTER ID:%u\r\n", LPN, cid);

    return cid;
}

VOID DFTL_GLOBAL::SB_INIT()
{
    SBINFO_MGR* sbm = GetSBInfoMgr();
    INT32 c = DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();

    // 프리 리스트 헤드 초기화 및 카운터 리셋
    INIT_LIST_HEAD(&sbm->m_dlFreeList);
    sbm->m_nFreeCount = 0;

    for (INT32 vbn = 0; vbn < c; vbn++)
    {
        SBINFO* sb = &sbm->m_pastSBInfo[vbn];

        // 방어적으로 리스트 노드 초기화 (기존 연결 제거)
        INIT_LIST_HEAD(&sb->m_dlList);

        // 제외: BAD 이거나 VBN <= 20 (메타 예약 구간)
        if (sb->m_bBad != 0)  	continue;
        if (sb->m_bMeta)		continue;

        // 프리 조건: 아직 사용 중이 아니어야 함
        if (sb->m_nUSED != 0) continue;

        // 프리 리스트에 push
        list_add_tail(&sb->m_dlList, &sbm->m_dlFreeList);
        sbm->m_nFreeCount++;
    }

    {
        UINT32 freeWalk = 0, badInFree = 0, metaInFree = 0, usedInFree = 0;

        PRINTF("[SB_INIT] ===== FREE SB LIST START =====\n\r");
        SBINFO* pos;
        list_for_each_entry(SBINFO, pos, &sbm->m_dlFreeList, m_dlList) {
//            PRINTF("[SB_INIT][FREE] VBN:%u, USED:%u, BAD:%u, META:%u\n\r",
//                   pos->m_nVBN, pos->m_nUSED, pos->m_bBad, pos->m_bMeta);
            freeWalk++;

            if (pos->m_bBad)  badInFree++;
            if (pos->m_bMeta) metaInFree++;
            if (pos->m_nUSED) usedInFree++;
        }
        PRINTF("[SB_INIT] FREE COUNT (walked): %u\n\r", freeWalk);
        PRINTF("[SB_INIT] FREE COUNT (sbm->m_nFreeCount): %u\n\r", sbm->m_nFreeCount);
        if (badInFree || metaInFree || usedInFree) {
            PRINTF("[SB_INIT][WARN] bad:%u, meta:%u, used:%u entries wrongly in FREE list!\n\r",
                   badInFree, metaInFree, usedInFree);
        }
        PRINTF("[SB_INIT] ===== FREE SB LIST END =====\n\r");
    }
    SB_INIT_FLAG = TRUE;
}


VIRTUAL VOID 
DFTL_GLOBAL::Initialize(VOID)
{
	SB_INIT_FLAG = FALSE;
    SB_PRINT_FLAG = FALSE;
	META_CNT = 0;

	for (int i=0; i<USER_CLUSTERS; i++)
	{
		m_wp_ch[i] = 0;
		m_wp_wy[i] = 0;
		m_page_cnt[i] = 0;

		m_gc_wp_ch[i] = 0;
		m_gc_wp_wy[i] = 0;
		m_gc_page_cnt[i] = 0;

		cluster_util[i] = 0;
	}

//	m_ActiveBlockAllocCnt = USER_CHANNELS * USER_WAYS;
//	m_GCActiveBlockAllocCnt = USER_CHANNELS * USER_WAYS;

	m_pstInstance = this;
	_Initialize();
	GetVNandMgr()->Initialize();
	GetMetaMgr()->Initialize();
	GetMetaL2VMgr()->Initialize();

	TrimBitmap_Init();
	TrimPending_Clear();

	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			GetVBInfoMgr(channel, way)->Initialize();
		}
	}
	GetUserBlockMgr()->Initialize(USER_BLOCK_MGR);		// must be formantted before meta block mgr
#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Initialize(META_BLOCK_MGR);
#endif
	GetRequestMgr()->Initialize();
	GetBufferMgr()->Initialize();
	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			for (int cluster = 0; cluster < USER_CLUSTERS; cluster++)
			{
				GetActiveBlockMgr(cluster, channel, way)->Initialize(cluster, channel, way);
			}
			GetGCMgr(channel, way)->Initialize(GetGCTh(), IOTYPE_GC, channel, way);
#if (SUPPORT_META_DEMAND_LOADING == 1)
			GetMetaGCMgr(channel, way)->Initialize(META_GC_THRESHOLD, IOTYPE_META, channel, way);
#endif
		}
	}
	_PrintInfo();
	m_MetaGCing = FALSE;

	GetReadCacheMgr()->Initialize();
	GetSBInfoMgr()->Initialize();
}



#define TRIM_BITMAP_BYTES ((TOTAL_LPN_COUNT + 7ull) / 8ull)
#ifndef TRIM_BITMAP_ALIGN
#define TRIM_BITMAP_ALIGN (64)
#endif

#ifndef TB_NUM_SEGS
#define TB_NUM_SEGS ((UINT32)(((TOTAL_LPN_COUNT) + (TB_SEG_LPNS) - 1u) / (TB_SEG_LPNS)))
#endif

volatile UINT8* g_trim_bitmap     	= NULL; // LPN 비트맵
volatile UINT16* g_trim_seg_count	= NULL; // ★ 세그먼트 요약 플래그
volatile UINT32 g_trim_pending    	= 0;
volatile UINT32 g_trim_going    	= 0;

#define TRIM_SEG_BYTES      (TB_NUM_SEGS)
#define LPNS_PER_SEGMENT	(1024)
#define SEGMENT_COUNT       (TOTAL_LPN_COUNT / LPNS_PER_SEGMENT)

void TrimBitmap_Init(void)
{
    g_trim_bitmap = (volatile UINT8*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)TRIM_BITMAP_BYTES, /*align=*/64);
    DEBUG_ASSERT(g_trim_bitmap != NULL);
    OSAL_MEMSET((void*)g_trim_bitmap, 0, (UINT32)TRIM_BITMAP_BYTES);

    UINT32 count_array_size = SEGMENT_COUNT * sizeof(UINT16);
    g_trim_seg_count = (volatile UINT16*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)count_array_size, /*align=*/64);
    DEBUG_ASSERT(g_trim_seg_count != NULL);
    OSAL_MEMSET((void*)g_trim_seg_count, 0, count_array_size);
}

void SetTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        set_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    UINT32 head_end = seg_end_lpn(segS);
    set_range_same_segment(nStartLPN, head_end, segS);
    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0xFF, (size_t)seg_bytes);
        g_trim_seg_count[s] = LPNS_PER_SEGMENT;
    }

    UINT32 tail_begin = seg_base_lpn(segE);
    set_range_same_segment(tail_begin, nEndLPN, segE);
    TrimPending_Set();
}

void ClearTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        clear_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    UINT32 head_end = seg_end_lpn(segS);
    clear_range_same_segment(nStartLPN, head_end, segS);

    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0x00, (size_t)seg_bytes);
        g_trim_seg_count[s] = 0;
    }

    UINT32 tail_begin = seg_base_lpn(segE);
    clear_range_same_segment(tail_begin, nEndLPN, segE);
}

void CheckPendingTrim()
{
    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
    {
        if (g_trim_seg_count[i] > 0)
        {
            return;
        }
    }
    TrimPending_Clear();
//    xil_printf("TRIM DONE\r\n");
}

//UINT32 FindTopKTrimSegments(UINT32 k)
//{
//	UINT32 Load_CNT = 0;
//    if (k == 0) {
//        return 0;
//    }
//    UINT16 anTopCounts[k];
//    UINT32 anTopIndices[k];
//    OSAL_MEMSET(anTopCounts, 0, sizeof(UINT16) * k);
//    OSAL_MEMSET(anTopIndices, 0, sizeof(UINT32) * k);
//    UINT16 nMinCountInTopK = 0;
//    UINT32 nMinCountIdx = 0;
//
//    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
//    {
//        UINT16 nCurrentCount = g_trim_seg_count[i];
//        if (nCurrentCount <= nMinCountInTopK) {
//            continue;
//        }
//        anTopCounts[nMinCountIdx] = nCurrentCount;
//        anTopIndices[nMinCountIdx] = i;
//        nMinCountInTopK = anTopCounts[0];
//        nMinCountIdx = 0;
//        for (UINT32 j = 1; j < k; ++j) {
//            if (anTopCounts[j] < nMinCountInTopK) {
//                nMinCountInTopK = anTopCounts[j];
//                nMinCountIdx = j;
//            }
//        }
//    }
//    UINT32 LOOP_CNT = 0;
//    for (UINT32 i = 0; i < k; ++i)
//    {
//        META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
//        UINT32 meta_base_lpn = anTopIndices[i] * 1024;
//        UINT32 nMaxCount = anTopCounts[i];
//        if (nMaxCount > 0)
//        {
//        	if (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE)
//        		Load_CNT++;
//
//            while (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE)
//            {
//            	LOOP_CNT += 1;
//                pstMetaMgr->LoadMeta(meta_base_lpn, 1);
//                META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
//                META_REQUEST* pstRequest;
//
//                do {
//                    REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
//                    pstReqMgr->_ProcessMetaRequestWaitQ();
//                    FIL_Run();
//                    pstRequest = pstMetaReqInfo->GetDoneRequest();
//                    if (pstRequest != NULL) {
//                        pstRequest->Run();
//                    }
//                } while (pstRequest != NULL);
//            }
//        }
//    }
//    return Load_CNT;
//}

static inline UINT32 get_cluster_size_in_lpn(void)
{
    UINT32 total_lpn = DFTL_GLOBAL::GetInstance()->GetLPNCount();
    UINT32 cnum      = USER_CLUSTERS;
    return total_lpn / cnum; // 등분 전제
}

static inline UINT32 get_cluster_id_from_seg(UINT32 seg_idx)
{
    UINT32 base_lpn = seg_idx * 1024u; // SEGMENT_LPN 사용 안 함
    UINT32 csize    = get_cluster_size_in_lpn();
    UINT32 cid      = base_lpn / csize;
    UINT32 cnum     = USER_CLUSTERS;
    return (cid >= cnum) ? (cnum - 1u) : cid; // 경계 보호
}

#ifndef WEIGHT_MIN
#define WEIGHT_MIN 1u
#endif
#ifndef WEIGHT_MAX
#define WEIGHT_MAX 100u   // 크게 줄수록 분포가 더 벌어짐
#endif

static inline void compute_util_min_max(UINT32* out_min, UINT32* out_max)
{
    const UINT32 C = USER_CLUSTERS;
    UINT32 umin = 0xFFFFFFFFu, umax = 0u;
    for (UINT32 c = 0; c < C; ++c) {
        UINT32 u = DFTL_GLOBAL::GetInstance()->cluster_util[c];
        if (u < umin) umin = u;
        if (u > umax) umax = u;
    }
    if (umin == 0xFFFFFFFFu) umin = 0u; // 방어
    *out_min = umin;
    *out_max = umax;
}

static inline UINT32 weight_from_util_contrast(UINT32 util, UINT32 umin, UINT32 umax)
{
    const UINT32 WMIN  = WEIGHT_MIN;
    const UINT32 WMAX  = WEIGHT_MAX;
    const UINT32 WSPAN = (WMAX > WMIN) ? (WMAX - WMIN) : 0u;

    if (WSPAN == 0u) return WMIN;         // WMAX==WMIN이면 상수 가중치
    if (umax <= umin) return WMIN + (WSPAN >> 1); // 모두 같은 util → 중간값

    UINT32 range = umax - umin;           // > 0
    UINT32 inv   = umax - util;           // util 낮을수록 큼

    // 정수 대비 강화: inv^2 / range^2
    // 64-bit로 overflow 방지
    UINT64 num   = (UINT64)inv   * (UINT64)inv;
    UINT64 denom = (UINT64)range * (UINT64)range;

    UINT32 add = (UINT32)((num * (UINT64)WSPAN) / denom);
    UINT32 w   = WMIN + add;
    if (w < 1u) w = 1u;
    return w;
}

static inline UINT32 weight_from_cluster_util(UINT32 cid)
{
    const UINT32 csize      = get_cluster_size_in_lpn();
    const UINT32 util_count = DFTL_GLOBAL::GetInstance()->cluster_util[cid];
    const UINT32 denom      = (util_count == 0u) ? 1u : util_count;
    UINT32 w = (csize + denom - 1u) / denom; // ceil(csize/denom)
    if (w == 0u) w = 1u;
    return w;
}

static UINT32 select_from_one_level(UINT16 level_cnt,
                                    UINT32* out_idx, UINT32* out_n_io,
                                    UINT32* R_io)
{
    UINT32 R = *R_io;
    if (R == 0u) return 0u;

    const UINT32 C_eff = USER_CLUSTERS;

    static UINT32 bucket_counts[USER_CLUSTERS];
    static UINT32 bucket_starts[USER_CLUSTERS + 1]; // prefix-sum 센티넬 위해 +1
    static UINT32 bucket_cursor[USER_CLUSTERS];
    static UINT32 candidates[SEGMENT_COUNT];

    for (UINT32 c = 0; c < C_eff; ++c) bucket_counts[c] = 0;

    // 이번 레벨 후보 개수 집계
    for (UINT32 seg = 0; seg < SEGMENT_COUNT; ++seg) {
        if (g_trim_seg_count[seg] == level_cnt) {
            UINT32 cid = get_cluster_id_from_seg(seg);
            if (cid >= C_eff) continue;
            bucket_counts[cid]++;
        }
    }

    UINT32 total_candidates = 0;
    for (UINT32 c = 0; c < C_eff; ++c) total_candidates += bucket_counts[c];

    if (total_candidates == 0u) return 0u;

    // 후보 ≤ 남은 슬롯: 전부 선택
    if (total_candidates <= R) {
        bucket_starts[0] = 0;
        for (UINT32 c = 1; c <= C_eff; ++c)
            bucket_starts[c] = bucket_starts[c - 1] + bucket_counts[c - 1];
        for (UINT32 c = 0; c < C_eff; ++c) bucket_cursor[c] = bucket_starts[c];

        for (UINT32 seg = 0; seg < SEGMENT_COUNT; ++seg) {
            if (g_trim_seg_count[seg] == level_cnt) {
                UINT32 cid = get_cluster_id_from_seg(seg);
                if (cid >= C_eff) continue;
                candidates[bucket_cursor[cid]++] = seg; // seg index 오름차순으로 채워짐
            }
        }

        UINT32 copied = 0;
        for (UINT32 c = 0; c < C_eff; ++c) {
            UINT32 start = bucket_starts[c];
            UINT32 cap   = bucket_counts[c];
            for (UINT32 t = 0; t < cap && copied < R; ++t) {
                out_idx[*out_n_io + copied] = candidates[start + t];
                copied++;
            }
        }
        *out_n_io += copied;
        *R_io     -= copied;
        return copied;
    }

    bucket_starts[0] = 0;
    for (UINT32 c = 1; c <= C_eff; ++c)
        bucket_starts[c] = bucket_starts[c - 1] + bucket_counts[c - 1];
    for (UINT32 c = 0; c < C_eff; ++c) bucket_cursor[c] = bucket_starts[c];

    for (UINT32 seg = 0; seg < SEGMENT_COUNT; ++seg) {
        if (g_trim_seg_count[seg] == level_cnt) {
            UINT32 cid = get_cluster_id_from_seg(seg);
            if (cid >= C_eff) continue;
            candidates[bucket_cursor[cid]++] = seg;
        }
    }

    // 가중치 합
//    static UINT32 weights[USER_CLUSTERS];
//    UINT64 sumW = 0;
//    for (UINT32 c = 0; c < C_eff; ++c) {
//        UINT32 w = weight_from_cluster_util(c);
//        weights[c] = w;
//        sumW += (UINT64)w;
//    }
//    if (sumW == 0u) {
//        for (UINT32 c = 0; c < C_eff; ++c) weights[c] = 1u, sumW += 1u;
//    }

    // ---- NEW: util min/max 구하고 대비 강화 가중치로 계산 ----
    UINT32 umin, umax;
    compute_util_min_max(&umin, &umax);

    static UINT32 weights[USER_CLUSTERS];
    UINT64 sumW = 0;

    for (UINT32 c = 0; c < C_eff; ++c) {
        UINT32 util = DFTL_GLOBAL::GetInstance()->cluster_util[c];
        UINT32 w    = weight_from_util_contrast(util, umin, umax);

        weights[c] = w;
        sumW += (UINT64)w;
    }

    if (sumW == 0u) {
        for (UINT32 c = 0; c < C_eff; ++c) weights[c] = 1u, sumW += 1u;
    }


    static UINT32 alloc[USER_CLUSTERS];
    static UINT64 rem [USER_CLUSTERS];

    for (UINT32 c = 0; c < C_eff; ++c) {
        UINT64 num = (UINT64)weights[c] * (UINT64)R;
        alloc[c] = (UINT32)(num / sumW);
        rem[c]   = (num % sumW);

        UINT32 cap = bucket_counts[c];
        if (alloc[c] > cap) alloc[c] = cap;
    }

    UINT32 given = 0;
    for (UINT32 c = 0; c < C_eff; ++c) given += alloc[c];

    while (given < R) {
        UINT32 best_c = C_eff;
        UINT64 best_r = 0;

        for (UINT32 c = 0; c < C_eff; ++c) {
            UINT32 cap = bucket_counts[c];
            if (alloc[c] >= cap) continue;
            UINT64 r = rem[c];
            if (r > best_r || (r == best_r && c < best_c)) {
                best_r = r; best_c = c;
            }
        }
        if (best_c == C_eff) break;

        alloc[best_c] += 1;
        given += 1;
        if (rem[best_c] > 0) rem[best_c] = 0;
    }

    UINT32 picked = 0;
    for (UINT32 c = 0; c < C_eff; ++c) {
        UINT32 start = bucket_starts[c];
        UINT32 take  = alloc[c];
        for (UINT32 t = 0; t < take; ++t) {
            out_idx[*out_n_io + picked] = candidates[start + t];
            picked++;
        }
    }

    *out_n_io += picked;
    *R_io     -= picked;
    return picked;
}

UINT32 FindTopKTrimSegments(UINT32 k)
{
    if (k == 0u) return 0u;

    UINT16 max_cnt = 0;
    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i) {
        if (g_trim_seg_count[i] > max_cnt) max_cnt = g_trim_seg_count[i];
    }
    if (max_cnt == 0u) return 0u;

    static UINT32 chosen_idx[1024];
    if (k > 1024) k = 1024;

    UINT32 out_n = 0;
    UINT32 R     = k;

    for (UINT16 level = max_cnt; level >= 1 && R > 0; --level) {
        UINT32 before_out_n = out_n;
        select_from_one_level(level, chosen_idx, &out_n, &R);
        UINT32 picked = out_n - before_out_n;
        if (level == 1) break; // underflow 방지
    }

    {
    	const UINT32 C = USER_CLUSTERS;

    	// 1) 클러스터별 선택 개수 집계
    	UINT32 sel_counts[USER_CLUSTERS];
    	for (UINT32 c = 0; c < C; ++c) sel_counts[c] = 0;

    	for (UINT32 i = 0; i < out_n; ++i) {
    		UINT32 seg = chosen_idx[i];
    		UINT32 cid = get_cluster_id_from_seg(seg);
    		if (cid < C) sel_counts[cid]++;
    	}

    	// 2) 클러스터 요약: CLUSTER / UTIL / WEIGHT / SEL
    	xil_printf("[WEIGHT] umin=%u umax=%u WMIN=%u WMAX=%u\r\n", umin, umax, WEIGHT_MIN, WEIGHT_MAX);

    	for (UINT32 c = 0; c < C; ++c) {
    		if (sel_counts[c] == 0) continue;
    		UINT32 util   = DFTL_GLOBAL::GetInstance()->cluster_util[c];
    		UINT32 weight = weight_from_cluster_util(c);
    		xil_printf("CLUSTER=%u UTIL=%u WEIGHT=%u SEL=%u\r\n",
    				c, util, weight, sel_counts[c]);
    	}

    	// 3) 세그먼트 상세: SEG / DENS / CLUSTER
    	for (UINT32 i = 0; i < out_n; ++i) {
    		UINT32 seg   = chosen_idx[i];
    		UINT16 dens  = g_trim_seg_count[seg];
    		UINT32 cid   = get_cluster_id_from_seg(seg);
    		xil_printf("  SEG=%u DENS=%u CLUSTER=%u\r\n", seg, dens, cid);
    	}
    }

    // 3) 선택된 세그먼트 메타 로드
    META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
    UINT32 Load_CNT = 0;
    UINT32 LOOP_CNT = 0;

    for (UINT32 i = 0; i < out_n; ++i) {
        UINT32 seg = chosen_idx[i];
        UINT32 meta_base_lpn = seg * 1024u; // SEGMENT_LPN 사용 안 함
        UINT16 cnt = g_trim_seg_count[seg];
        if (cnt == 0u) continue;

        if (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE) Load_CNT++;

        while (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE) {
            LOOP_CNT += 1;
            pstMetaMgr->LoadMeta(meta_base_lpn, 1);

            META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
            META_REQUEST* pstRequest;
            do {
                REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                pstReqMgr->_ProcessMetaRequestWaitQ();
                FIL_Run();
                pstRequest = pstMetaReqInfo->GetDoneRequest();
                if (pstRequest != NULL) {
                    pstRequest->Run();
                }
            } while (pstRequest != NULL);
        }
    }

    return Load_CNT;
}

VIRTUAL BOOL
DFTL_GLOBAL::Format(VOID)
{
	BOOL	bRet;

	GetUserBlockMgr()->Format();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Format();
	bRet = GetMetaL2VMgr()->Format();
#endif

	bRet = GetMetaMgr()->Format();			// THIS MUST BE AT THE END OF FORMAT ROUTINE

	return bRet;
}

VIRTUAL VOID 
DFTL_GLOBAL::Run(VOID)
{
	FIL_Run();
	GetRequestMgr()->Run();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->CheckAndStartGC();
		}
	}
#endif
	if (GetSuperGCMgr()->CheckAndStartGC())
	{
		for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
			for (UINT32 way = 0; way < USER_WAYS; way++) {
				GetGCMgr(channel, way)->CheckAndStartGC();
			}
		}
	}

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->Run();
		}
	}
#endif
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetGCMgr(channel, way)->Run();
		}
	}
}

/*
	@brief	Add HIL read request to waitQ
*/
VIRTUAL VOID
DFTL_GLOBAL::ReadPage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;

	if (nLPN == 77)
	{
		if ((nCount == 77) || (nCount == 78))
			DFTL_PrintProfile(0);
		else
			DFTL_PrintProfile(1);
		m_bEnable += 1;
	}

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_READ_WAIT, NVME_CMD_OPCODE_READ, 
						nLPN, nCmdSlotTag, nCount);
#ifndef WIN32
	//xil_printf("1	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_read, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::WritePage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;
	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_WRITE_WAIT, NVME_CMD_OPCODE_WRITE, 
		nLPN, nCmdSlotTag, nCount);

//	if (m_bEnable > 1)
//		xil_printf("WRITE REQ INIT [LPN:%u, Length:%u]\r\n", nLPN, nCount);

#ifndef WIN32
	//xil_printf("7	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_write, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::DatasetManagement(UINT32 nCmdSlotTag, UINT32 nr, UINT32 ad)
{
	HIL_REQUEST*	pstRequest;

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_DSM_WAIT, NVME_CMD_OPCODE_DSM,
		ad, nCmdSlotTag, nr);

	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_Discard);
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::CallBack(FTL_REQUEST_ID stReqID)
{
#if (UNIT_TEST_FIL_PERF == 1)
	return;
#endif

	switch (stReqID.stCommon.nType)
	{
	case FTL_REQUEST_ID_TYPE_HIL_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		HIL_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetHILRequestInfo();
		HIL_REQUEST_PER_WAY * pstRequest = pstRequestInfo->GetRequest_per_way(stReqID.stHIL.nRequestIndex);

		pstRequest->IncreaseDoneCount();
		pstRequest->pBufEntry[stReqID.stHIL.bufOffset]->readDone = 1;

		if (pstRequest->GetDoneCount() == pstRequest->GetLPNCount())
		{
			// all read done  
			// remove from issued Q
			pstRequestInfo->RemoveFromIssuedQ_per_way(pstRequest);

			pstRequest->HDMAIssue();

			// add to done Q
			pstRequestInfo->AddToDoneQ_per_way(pstRequest);		// wait for HDMA Issue

			pstRequest->GoToNextStatus();		// NAND Issued -> NAND_DONE
		}

		break;
	}
	case FTL_REQUEST_ID_TYPE_WRITE:
	{
		// Pysical page program done
		INT32	nIndex = stReqID.stProgram.nActiveBlockIndex;
		IOTYPE	eIOType = static_cast<IOTYPE>(stReqID.stProgram.nIOType);

		ACTIVE_BLOCK* pstActiveBlock = DFTL_GLOBAL::GetActiveBlockMgr(stReqID.cluster, stReqID.channel, stReqID.way)->GetActiveBlock(nIndex, eIOType);
		pstActiveBlock->ProgramDone(stReqID.stProgram.nBufferingIndex);
		break;
	}
	case FTL_REQUEST_ID_TYPE_GC_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		GC_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetGCRequestInfo();
		GC_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stGC.nRequestIndex);
		pstRequest->GCReadDone();
		break;
	}
#if (SUPPORT_META_DEMAND_LOADING == 1)
	case FTL_REQUEST_ID_TYPE_META_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
		META_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stMeta.nRequestIndex);

		pstRequestInfo->RemoveFromIssuedQ(pstRequest);
		pstRequestInfo->AddToDoneQ(pstRequest);
		pstRequest->GoToNextStatus();					// NAND Issued -> NAND_DONE

		break;
	}
#endif
	default:
		ASSERT(0);
		break;
	}
}

VIRTUAL VOID 
DFTL_GLOBAL::IOCtl(IOCTL_TYPE eType)
{
	switch (eType)
	{
	case IOCTL_INIT_PROFILE_COUNT:
		m_stProfile.Initialize();
		break;

	case IOCTL_PRINT_PROFILE_COUNT:
		m_stProfile.Print();
		break;

	default:
		ASSERT(0);		// unknown type
		break;
	}

	return;
}

VOID
DFTL_GLOBAL::SetStatus(DFTL_STATUS eStatus)
{
	m_eStatus = static_cast<DFTL_STATUS>(m_eStatus | eStatus);
}

BOOL
DFTL_GLOBAL::CheckStatus(DFTL_STATUS eStatus)
{
	return (m_eStatus & eStatus) ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	static function
//

VOID 
DFTL_GLOBAL::_Initialize(VOID)
{
	UINT32 nPPagesPerVBlock = m_stVNand.GetPPagesPerVBlock();
	m_nPhysicalFlashSizeKB = USER_CHANNELS * USER_WAYS * m_stVNand.GetVBlockCount() * nPPagesPerVBlock * (PHYSICAL_PAGE_SIZE / KB);

	m_nVBlockSizeKB			= nPPagesPerVBlock * PHYSICAL_PAGE_SIZE;
	m_nVPagesPerVBlock		= m_stVNand.GetVPagesPerVBlock();
	m_nLPagesPerVBlockBits	= UTIL_GetBitCount(m_nVPagesPerVBlock);
	m_nLPagesPerVBlockMask	= (1 << m_nLPagesPerVBlockBits) - 1;

	m_fOverProvisionRatio = (float)OVERPROVISION_RATIO_DEFAULT;
	m_nOverprovisionSizeKB = (INT64)(m_nPhysicalFlashSizeKB * m_fOverProvisionRatio);
	m_nLogicalFlashSizeKB = m_nPhysicalFlashSizeKB - m_nOverprovisionSizeKB;

#if (SUPPORT_STATIC_DENSITY != 0)
	UINT32 nLogicalFlashSizeKB = SUPPORT_STATIC_DENSITY * (GB / KB);

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);

	m_nLogicalFlashSizeKB = nLogicalFlashSizeKB;		// update logical flash size

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);
#endif

	m_nLPNCount			= m_nLogicalFlashSizeKB / LOGICAL_PAGE_SIZE_KB;

	m_nVBlockCount		= m_stVNand.GetVBlockCount();

#if (SUPPORT_META_BLOCK == 1)
	m_bEnableMetaBlock = TRUE;
#else
	m_bEnableMetaBlock = FALSE;
#endif

	m_nGCTh = FREE_BLOCK_GC_THRESHOLD_DEFAULT;

	HIL_SetStorageBlocks(m_nLPNCount);

	m_stProfile.Initialize();
}

VOID 
DFTL_GLOBAL::_PrintInfo(VOID)
{
#if defined(FPM_FTL)
	char	psFTL[] = "FPMFTL";
#elif defined(DFTL)
	char	psFTL[] = "DFTL";
#else
#error check config
#endif

	PRINTF("[%s] Physical Density: %d MB \n\r", psFTL, m_nPhysicalFlashSizeKB / KB);
	PRINTF("[%s] Logical Density: %d MB \n\r", psFTL, m_nLogicalFlashSizeKB / KB);
}

VOID SBINFO_MGR::Initialize()
{
	INT32 nSize = sizeof(SBINFO) * DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();
	m_pastSBInfo = (SBINFO *)OSAL_MemAlloc(MEM_TYPE_FW_DATA, nSize, OSAL_MEMALLOC_FW_ALIGNMENT);
	m_nFreeCount = 0;

	int c = DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();
	for (int i=0; i<c; i++)
	{
		m_pastSBInfo[i].SetFree();
		m_pastSBInfo[i].m_nVBN = i;
		m_pastSBInfo[i].m_nUSED = 0;
		m_pastSBInfo[i].m_bBad = 0;
		if (i<20)
		{
//			xil_printf("SBINFO META INIT %d\r\n", i);
			m_pastSBInfo[i].m_bMeta = 1;
		}
		else
		{
//			xil_printf("SBINFO HOST INIT %d\r\n", i);
			m_pastSBInfo[i].m_bMeta = 0;
		}
	}
}

VOID Read_Cache::Initialize()
{
	for (int i = 0; i < MAX_READ_CACHE_ENTRY; i++)
	{
		source_lpn[i] = 0xffffffff;
		nVPPN[i] = 0xffffffff;
		Buf[i] = DFTL_GLOBAL::GetBufferMgr()->Allocate();
		if (Buf[i] == NULL)
			ASSERT(0);
		Buf[i]->readDone = 1;
	}

	return VOID();
}

BUFFER_ENTRY * Read_Cache::change_next_buffer(UINT32 src_lpn, BUFFER_ENTRY * input_buf, UINT32 channel, UINT32 way)
{
	BUFFER_ENTRY * ret;

	UINT32 iter;
//	UINT32 channel, way;
//	channel = get_channel_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
//	way = get_way_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;

	for (iter = start_offset; iter < end_offset; iter++)
	{
		if (Buf[iter]->refCount == 0)
		{
			break;
		}
	}
	if (iter == end_offset)
		return NULL;

	ret = Buf[iter];
	source_lpn[iter] = src_lpn;
	Buf[iter] = input_buf;
	nVPPN[iter] = input_buf->nVPPN >> NUM_BIT_LPN_PER_PAGE;
	return ret;
}


BUFFER_ENTRY * Read_Cache::get_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
			return Buf[iter];
	}
	return NULL;
}

VOID Read_Cache::free_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
		{
			Buf[iter]->nVPPN = 0xffffffff;
			nVPPN[iter] = 0xffffffff;
			return;
		}
	}
}
