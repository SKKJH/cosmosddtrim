/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "hil.h"

#include "dftl_internal.h"

DFTL_GLOBAL* DFTL_GLOBAL::m_pstInstance;

VOID DFTL_GLOBAL::WritePtr_GetAndAdvance(UINT32 clusterID)
{
    m_page_cnt[clusterID]++;
    if (m_page_cnt[clusterID] >= LPN_PER_PHYSICAL_PAGE) {
        m_page_cnt[clusterID] = 0;
        m_wp_ch[clusterID]++;
        if (m_wp_ch[clusterID] >= USER_CHANNELS) {
            m_wp_ch[clusterID] = 0;
            m_wp_wy[clusterID]++;
            if (m_wp_wy[clusterID] >= USER_WAYS) {
                m_wp_wy[clusterID] = 0;
            }
        }
    }
}

VOID DFTL_GLOBAL::GC_WritePtr_GetAndAdvance(UINT32 clusterID)
{
    m_gc_page_cnt[clusterID]++;
    if (m_gc_page_cnt[clusterID] >= LPN_PER_PHYSICAL_PAGE) {
        m_gc_page_cnt[clusterID] = 0;
        m_gc_wp_ch[clusterID]++;
        if (m_gc_wp_ch[clusterID] >= USER_CHANNELS) {
            m_gc_wp_ch[clusterID] = 0;
            m_gc_wp_wy[clusterID]++;
            if (m_gc_wp_wy[clusterID] >= USER_WAYS) {
                m_gc_wp_wy[clusterID] = 0;
            }
        }
    }
}

VOID DFTL_GLOBAL::DebugBlockPrint(UINT32 FLAG)
{
    GetUserBlockMgr()->DebugPrintAllByVBN(FLAG);
}

UINT32 DFTL_GLOBAL::GetClusterID(UINT32 LPN)
{
    UINT64 num   = (UINT64)LPN * (UINT64)USER_CLUSTERS;
    UINT32 cid   = (UINT32)(num / (UINT64)m_nLPNCount);

    if (cid >= USER_CLUSTERS)
    {
    	xil_printf("Wrong CID\r\n");
    	assert(0);
    }

//    xil_printf("	[MAKE] LPN:%u, CLUSTER ID:%u\r\n", LPN, cid);

    return cid;
}

VOID DFTL_GLOBAL::SB_INIT()
{
    SBINFO_MGR* sbm = GetSBInfoMgr();
    INT32 c = DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();

    // 프리 리스트 헤드 초기화 및 카운터 리셋
    INIT_LIST_HEAD(&sbm->m_dlFreeList);
    sbm->m_nFreeCount = 0;

    for (INT32 vbn = 0; vbn < c; vbn++)
    {
        SBINFO* sb = &sbm->m_pastSBInfo[vbn];

        // 방어적으로 리스트 노드 초기화 (기존 연결 제거)
        INIT_LIST_HEAD(&sb->m_dlList);

        // 제외: BAD 이거나 VBN <= 20 (메타 예약 구간)
        if (sb->m_bBad != 0)  	continue;
        if (sb->m_bMeta)		continue;

        // 프리 조건: 아직 사용 중이 아니어야 함
        if (sb->m_nUSED != 0) continue;

        // 프리 리스트에 push
        list_add_tail(&sb->m_dlList, &sbm->m_dlFreeList);
        sbm->m_nFreeCount++;
    }

    {
        UINT32 freeWalk = 0, badInFree = 0, metaInFree = 0, usedInFree = 0;

        PRINTF("[SB_INIT] ===== FREE SB LIST START =====\n\r");
        SBINFO* pos;
        list_for_each_entry(SBINFO, pos, &sbm->m_dlFreeList, m_dlList) {
//            PRINTF("[SB_INIT][FREE] VBN:%u, USED:%u, BAD:%u, META:%u\n\r",
//                   pos->m_nVBN, pos->m_nUSED, pos->m_bBad, pos->m_bMeta);
            freeWalk++;

            if (pos->m_bBad)  badInFree++;
            if (pos->m_bMeta) metaInFree++;
            if (pos->m_nUSED) usedInFree++;
        }
        PRINTF("[SB_INIT] FREE COUNT (walked): %u\n\r", freeWalk);
        PRINTF("[SB_INIT] FREE COUNT (sbm->m_nFreeCount): %u\n\r", sbm->m_nFreeCount);
        if (badInFree || metaInFree || usedInFree) {
            PRINTF("[SB_INIT][WARN] bad:%u, meta:%u, used:%u entries wrongly in FREE list!\n\r",
                   badInFree, metaInFree, usedInFree);
        }
        PRINTF("[SB_INIT] ===== FREE SB LIST END =====\n\r");
    }
    SB_INIT_FLAG = TRUE;
}


VIRTUAL VOID 
DFTL_GLOBAL::Initialize(VOID)
{
	SB_INIT_FLAG = FALSE;
    SB_PRINT_FLAG = FALSE;
	META_CNT = 0;

	for (int i=0; i<USER_CLUSTERS; i++)
	{
		m_wp_ch[i] = 0;
		m_wp_wy[i] = 0;
		m_page_cnt[i] = 0;

		m_gc_wp_ch[i] = 0;
		m_gc_wp_wy[i] = 0;
		m_gc_page_cnt[i] = 0;
	}

//	m_ActiveBlockAllocCnt = USER_CHANNELS * USER_WAYS;
//	m_GCActiveBlockAllocCnt = USER_CHANNELS * USER_WAYS;

	m_pstInstance = this;
	_Initialize();
	GetVNandMgr()->Initialize();
	GetMetaMgr()->Initialize();
	GetMetaL2VMgr()->Initialize();

	TrimBitmap_Init();
	TrimPending_Clear();

	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			GetVBInfoMgr(channel, way)->Initialize();
		}
	}
	GetUserBlockMgr()->Initialize(USER_BLOCK_MGR);		// must be formantted before meta block mgr
#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Initialize(META_BLOCK_MGR);
#endif
	GetRequestMgr()->Initialize();
	GetBufferMgr()->Initialize();
	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			for (int cluster = 0; cluster < USER_CLUSTERS; cluster++)
			{
				GetActiveBlockMgr(cluster, channel, way)->Initialize(cluster, channel, way);
			}
			GetGCMgr(channel, way)->Initialize(GetGCTh(), IOTYPE_GC, channel, way);
#if (SUPPORT_META_DEMAND_LOADING == 1)
			GetMetaGCMgr(channel, way)->Initialize(META_GC_THRESHOLD, IOTYPE_META, channel, way);
#endif
		}
	}
	_PrintInfo();
	m_MetaGCing = FALSE;

	GetReadCacheMgr()->Initialize();
	GetSBInfoMgr()->Initialize();
}



#define TRIM_BITMAP_BYTES ((TOTAL_LPN_COUNT + 7ull) / 8ull)
#ifndef TRIM_BITMAP_ALIGN
#define TRIM_BITMAP_ALIGN (64)
#endif

#ifndef TB_NUM_SEGS
#define TB_NUM_SEGS ((UINT32)(((TOTAL_LPN_COUNT) + (TB_SEG_LPNS) - 1u) / (TB_SEG_LPNS)))
#endif

volatile UINT8* g_trim_bitmap     	= NULL; // LPN 비트맵
volatile UINT16* g_trim_seg_count	= NULL; // ★ 세그먼트 요약 플래그
volatile UINT32 g_trim_pending    	= 0;
volatile UINT32 g_trim_going    	= 0;

#define TRIM_SEG_BYTES      (TB_NUM_SEGS)
#define LPNS_PER_SEGMENT	(1024)
#define SEGMENT_COUNT       (TOTAL_LPN_COUNT / LPNS_PER_SEGMENT)

void TrimBitmap_Init(void)
{
    g_trim_bitmap = (volatile UINT8*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)TRIM_BITMAP_BYTES, /*align=*/64);
    DEBUG_ASSERT(g_trim_bitmap != NULL);
    OSAL_MEMSET((void*)g_trim_bitmap, 0, (UINT32)TRIM_BITMAP_BYTES);

    UINT32 count_array_size = SEGMENT_COUNT * sizeof(UINT16);
    g_trim_seg_count = (volatile UINT16*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)count_array_size, /*align=*/64);
    DEBUG_ASSERT(g_trim_seg_count != NULL);
    OSAL_MEMSET((void*)g_trim_seg_count, 0, count_array_size);
}

void SetTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        set_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    UINT32 head_end = seg_end_lpn(segS);
    set_range_same_segment(nStartLPN, head_end, segS);
    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0xFF, (size_t)seg_bytes);
        g_trim_seg_count[s] = LPNS_PER_SEGMENT;
    }

    UINT32 tail_begin = seg_base_lpn(segE);
    set_range_same_segment(tail_begin, nEndLPN, segE);
    TrimPending_Set();
}

void ClearTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        clear_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    UINT32 head_end = seg_end_lpn(segS);
    clear_range_same_segment(nStartLPN, head_end, segS);

    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0x00, (size_t)seg_bytes);
        g_trim_seg_count[s] = 0;
    }

    UINT32 tail_begin = seg_base_lpn(segE);
    clear_range_same_segment(tail_begin, nEndLPN, segE);
}

void CheckPendingTrim()
{
    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
    {
        if (g_trim_seg_count[i] > 0)
        {
            return;
        }
    }
    TrimPending_Clear();
}

UINT32 FindTopKTrimSegments(UINT32 k)
{
	UINT32 Load_CNT = 0;
    if (k == 0) {
        return 0;
    }
    UINT16 anTopCounts[k];
    UINT32 anTopIndices[k];
    OSAL_MEMSET(anTopCounts, 0, sizeof(UINT16) * k);
    OSAL_MEMSET(anTopIndices, 0, sizeof(UINT32) * k);
    UINT16 nMinCountInTopK = 0;
    UINT32 nMinCountIdx = 0;

    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
    {
        UINT16 nCurrentCount = g_trim_seg_count[i];
        if (nCurrentCount <= nMinCountInTopK) {
            continue;
        }
        anTopCounts[nMinCountIdx] = nCurrentCount;
        anTopIndices[nMinCountIdx] = i;
        nMinCountInTopK = anTopCounts[0];
        nMinCountIdx = 0;
        for (UINT32 j = 1; j < k; ++j) {
            if (anTopCounts[j] < nMinCountInTopK) {
                nMinCountInTopK = anTopCounts[j];
                nMinCountIdx = j;
            }
        }
    }
    UINT32 LOOP_CNT = 0;
    for (UINT32 i = 0; i < k; ++i)
    {
        META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
        UINT32 meta_base_lpn = anTopIndices[i] * 1024;
        UINT32 nMaxCount = anTopCounts[i];
        if (nMaxCount > 0)
        {
        	if (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE)
        		Load_CNT++;

            while (pstMetaMgr->IsMetaAvailable(meta_base_lpn, 0) == FALSE)
            {
            	LOOP_CNT += 1;
                pstMetaMgr->LoadMeta(meta_base_lpn, 1);
                META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
                META_REQUEST* pstRequest;

                do {
                    REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                    pstReqMgr->_ProcessMetaRequestWaitQ();
                    FIL_Run();
                    pstRequest = pstMetaReqInfo->GetDoneRequest();
                    if (pstRequest != NULL) {
                        pstRequest->Run();
                    }
                } while (pstRequest != NULL);
            }
        }
    }
    return Load_CNT;
}

VIRTUAL BOOL
DFTL_GLOBAL::Format(VOID)
{
	BOOL	bRet;

	GetUserBlockMgr()->Format();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Format();
	bRet = GetMetaL2VMgr()->Format();
#endif

	bRet = GetMetaMgr()->Format();			// THIS MUST BE AT THE END OF FORMAT ROUTINE

	return bRet;
}

VIRTUAL VOID 
DFTL_GLOBAL::Run(VOID)
{
	FIL_Run();
	GetRequestMgr()->Run();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->CheckAndStartGC();
		}
	}
#endif
	if (GetSuperGCMgr()->CheckAndStartGC())
	{
		for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
			for (UINT32 way = 0; way < USER_WAYS; way++) {
				GetGCMgr(channel, way)->CheckAndStartGC();
			}
		}
	}

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->Run();
		}
	}
#endif
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetGCMgr(channel, way)->Run();
		}
	}
}

/*
	@brief	Add HIL read request to waitQ
*/
VIRTUAL VOID
DFTL_GLOBAL::ReadPage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;

	if (nLPN == 77)
	{
		if ((nCount == 77) || (nCount == 78))
			DFTL_PrintProfile(0);
		else
			DFTL_PrintProfile(1);
		m_bEnable += 1;
	}

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_READ_WAIT, NVME_CMD_OPCODE_READ, 
						nLPN, nCmdSlotTag, nCount);
#ifndef WIN32
	//xil_printf("1	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_read, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::WritePage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;
	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_WRITE_WAIT, NVME_CMD_OPCODE_WRITE, 
		nLPN, nCmdSlotTag, nCount);

//	if (m_bEnable > 1)
//		xil_printf("WRITE REQ INIT [LPN:%u, Length:%u]\r\n", nLPN, nCount);

#ifndef WIN32
	//xil_printf("7	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_write, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::DatasetManagement(UINT32 nCmdSlotTag, UINT32 nr, UINT32 ad)
{
	HIL_REQUEST*	pstRequest;

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

	pstRequest->Initialize(HIL_REQUEST_DSM_WAIT, NVME_CMD_OPCODE_DSM,
		ad, nCmdSlotTag, nr);

	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_Discard);
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::CallBack(FTL_REQUEST_ID stReqID)
{
#if (UNIT_TEST_FIL_PERF == 1)
	return;
#endif

	switch (stReqID.stCommon.nType)
	{
	case FTL_REQUEST_ID_TYPE_HIL_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		HIL_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetHILRequestInfo();
		HIL_REQUEST_PER_WAY * pstRequest = pstRequestInfo->GetRequest_per_way(stReqID.stHIL.nRequestIndex);

		pstRequest->IncreaseDoneCount();
		pstRequest->pBufEntry[stReqID.stHIL.bufOffset]->readDone = 1;

		if (pstRequest->GetDoneCount() == pstRequest->GetLPNCount())
		{
			// all read done  
			// remove from issued Q
			pstRequestInfo->RemoveFromIssuedQ_per_way(pstRequest);

			pstRequest->HDMAIssue();

			// add to done Q
			pstRequestInfo->AddToDoneQ_per_way(pstRequest);		// wait for HDMA Issue

			pstRequest->GoToNextStatus();		// NAND Issued -> NAND_DONE
		}

		break;
	}
	case FTL_REQUEST_ID_TYPE_WRITE:
	{
		// Pysical page program done
		INT32	nIndex = stReqID.stProgram.nActiveBlockIndex;
		IOTYPE	eIOType = static_cast<IOTYPE>(stReqID.stProgram.nIOType);

		ACTIVE_BLOCK* pstActiveBlock = DFTL_GLOBAL::GetActiveBlockMgr(stReqID.cluster, stReqID.channel, stReqID.way)->GetActiveBlock(nIndex, eIOType);
		pstActiveBlock->ProgramDone(stReqID.stProgram.nBufferingIndex);
		break;
	}
	case FTL_REQUEST_ID_TYPE_GC_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		GC_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetGCRequestInfo();
		GC_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stGC.nRequestIndex);
		pstRequest->GCReadDone();
		break;
	}
#if (SUPPORT_META_DEMAND_LOADING == 1)
	case FTL_REQUEST_ID_TYPE_META_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
		META_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stMeta.nRequestIndex);

		pstRequestInfo->RemoveFromIssuedQ(pstRequest);
		pstRequestInfo->AddToDoneQ(pstRequest);
		pstRequest->GoToNextStatus();					// NAND Issued -> NAND_DONE

		break;
	}
#endif
	default:
		ASSERT(0);
		break;
	}
}

VIRTUAL VOID 
DFTL_GLOBAL::IOCtl(IOCTL_TYPE eType)
{
	switch (eType)
	{
	case IOCTL_INIT_PROFILE_COUNT:
		m_stProfile.Initialize();
		break;

	case IOCTL_PRINT_PROFILE_COUNT:
		m_stProfile.Print();
		break;

	default:
		ASSERT(0);		// unknown type
		break;
	}

	return;
}

VOID
DFTL_GLOBAL::SetStatus(DFTL_STATUS eStatus)
{
	m_eStatus = static_cast<DFTL_STATUS>(m_eStatus | eStatus);
}

BOOL
DFTL_GLOBAL::CheckStatus(DFTL_STATUS eStatus)
{
	return (m_eStatus & eStatus) ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	static function
//

VOID 
DFTL_GLOBAL::_Initialize(VOID)
{
	UINT32 nPPagesPerVBlock = m_stVNand.GetPPagesPerVBlock();
	m_nPhysicalFlashSizeKB = USER_CHANNELS * USER_WAYS * m_stVNand.GetVBlockCount() * nPPagesPerVBlock * (PHYSICAL_PAGE_SIZE / KB);

	m_nVBlockSizeKB			= nPPagesPerVBlock * PHYSICAL_PAGE_SIZE;
	m_nVPagesPerVBlock		= m_stVNand.GetVPagesPerVBlock();
	m_nLPagesPerVBlockBits	= UTIL_GetBitCount(m_nVPagesPerVBlock);
	m_nLPagesPerVBlockMask	= (1 << m_nLPagesPerVBlockBits) - 1;

	m_fOverProvisionRatio = (float)OVERPROVISION_RATIO_DEFAULT;
	m_nOverprovisionSizeKB = (INT64)(m_nPhysicalFlashSizeKB * m_fOverProvisionRatio);
	m_nLogicalFlashSizeKB = m_nPhysicalFlashSizeKB - m_nOverprovisionSizeKB;

#if (SUPPORT_STATIC_DENSITY != 0)
	UINT32 nLogicalFlashSizeKB = SUPPORT_STATIC_DENSITY * (GB / KB);

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);

	m_nLogicalFlashSizeKB = nLogicalFlashSizeKB;		// update logical flash size

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);
#endif

	m_nLPNCount			= m_nLogicalFlashSizeKB / LOGICAL_PAGE_SIZE_KB;

	m_nVBlockCount		= m_stVNand.GetVBlockCount();

#if (SUPPORT_META_BLOCK == 1)
	m_bEnableMetaBlock = TRUE;
#else
	m_bEnableMetaBlock = FALSE;
#endif

	m_nGCTh = FREE_BLOCK_GC_THRESHOLD_DEFAULT;

	HIL_SetStorageBlocks(m_nLPNCount);

	m_stProfile.Initialize();
}

VOID 
DFTL_GLOBAL::_PrintInfo(VOID)
{
#if defined(FPM_FTL)
	char	psFTL[] = "FPMFTL";
#elif defined(DFTL)
	char	psFTL[] = "DFTL";
#else
#error check config
#endif

	PRINTF("[%s] Physical Density: %d MB \n\r", psFTL, m_nPhysicalFlashSizeKB / KB);
	PRINTF("[%s] Logical Density: %d MB \n\r", psFTL, m_nLogicalFlashSizeKB / KB);
}

VOID SBINFO_MGR::Initialize()
{
	INT32 nSize = sizeof(SBINFO) * DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();
	m_pastSBInfo = (SBINFO *)OSAL_MemAlloc(MEM_TYPE_FW_DATA, nSize, OSAL_MEMALLOC_FW_ALIGNMENT);
	m_nFreeCount = 0;

	int c = DFTL_GLOBAL::GetVNandMgr()->GetVBlockCount();
	for (int i=0; i<c; i++)
	{
		m_pastSBInfo[i].SetFree();
		m_pastSBInfo[i].m_nVBN = i;
		m_pastSBInfo[i].m_nUSED = 0;
		m_pastSBInfo[i].m_bBad = 0;
		if (i<20)
		{
//			xil_printf("SBINFO META INIT %d\r\n", i);
			m_pastSBInfo[i].m_bMeta = 1;
		}
		else
		{
//			xil_printf("SBINFO HOST INIT %d\r\n", i);
			m_pastSBInfo[i].m_bMeta = 0;
		}
	}
}

VOID Read_Cache::Initialize()
{
	for (int i = 0; i < MAX_READ_CACHE_ENTRY; i++)
	{
		source_lpn[i] = 0xffffffff;
		nVPPN[i] = 0xffffffff;
		Buf[i] = DFTL_GLOBAL::GetBufferMgr()->Allocate();
		if (Buf[i] == NULL)
			ASSERT(0);
		Buf[i]->readDone = 1;
	}

	return VOID();
}

BUFFER_ENTRY * Read_Cache::change_next_buffer(UINT32 src_lpn, BUFFER_ENTRY * input_buf, UINT32 channel, UINT32 way)
{
	BUFFER_ENTRY * ret;

	UINT32 iter;
//	UINT32 channel, way;
//	channel = get_channel_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
//	way = get_way_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;

	for (iter = start_offset; iter < end_offset; iter++)
	{
		if (Buf[iter]->refCount == 0)
		{
			break;
		}
	}
	if (iter == end_offset)
		return NULL;

	ret = Buf[iter];
	source_lpn[iter] = src_lpn;
	Buf[iter] = input_buf;
	nVPPN[iter] = input_buf->nVPPN >> NUM_BIT_LPN_PER_PAGE;
	return ret;
}


BUFFER_ENTRY * Read_Cache::get_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
			return Buf[iter];
	}
	return NULL;
}

VOID Read_Cache::free_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
		{
			Buf[iter]->nVPPN = 0xffffffff;
			nVPPN[iter] = 0xffffffff;
			return;
		}
	}
}
