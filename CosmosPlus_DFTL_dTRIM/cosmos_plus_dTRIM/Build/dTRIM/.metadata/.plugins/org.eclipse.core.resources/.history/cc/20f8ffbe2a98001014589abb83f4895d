/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#include "hil.h"
#include "xtime_l.h"
#include "dftl_internal.h"

DFTL_GLOBAL* DFTL_GLOBAL::m_pstInstance;

VIRTUAL VOID 
DFTL_GLOBAL::Initialize(VOID)
{
	m_pstInstance = this;
	_Initialize();
	GetVNandMgr()->Initialize();
	GetMetaMgr()->Initialize();
	GetMetaL2VMgr()->Initialize();

	TrimBitmap_Init();
	TrimPending_Clear();

	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			GetVBInfoMgr(channel, way)->Initialize();
		}
	}
	GetUserBlockMgr()->Initialize(USER_BLOCK_MGR);		// must be formantted before meta block mgr
#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Initialize(META_BLOCK_MGR);
#endif
	GetRequestMgr()->Initialize();
	GetBufferMgr()->Initialize();
	for (int channel = 0; channel < USER_CHANNELS; channel++) {
		for (int way = 0; way < USER_WAYS; way++) {
			GetActiveBlockMgr(channel, way)->Initialize(channel, way);
			GetGCMgr(channel, way)->Initialize(GetGCTh(), IOTYPE_GC, channel, way);
#if (SUPPORT_META_DEMAND_LOADING == 1)
			GetMetaGCMgr(channel, way)->Initialize(META_GC_THRESHOLD, IOTYPE_META, channel, way);
#endif
		}
	}
	_PrintInfo();
	m_MetaGCing = FALSE;

	GetReadCacheMgr()->Initialize();
}

#define TRIM_BITMAP_BYTES ((TOTAL_LPN_COUNT + 7ull) / 8ull) // 정렬(원하면 4096으로 올려도 됨)
#ifndef TRIM_BITMAP_ALIGN
#define TRIM_BITMAP_ALIGN (64)
#endif

#ifndef TB_NUM_SEGS
#define TB_NUM_SEGS ((UINT32)(((TOTAL_LPN_COUNT) + (TB_SEG_LPNS) - 1u) / (TB_SEG_LPNS)))
#endif

volatile UINT8* g_trim_bitmap     	= NULL; // LPN 비트맵
volatile UINT16* g_trim_seg_count	= NULL; // ★ 세그먼트 요약 플래그
volatile UINT32 g_trim_pending    	= 0;
volatile UINT32 g_trim_going    	= 0;

#define TRIM_SEG_BYTES      (TB_NUM_SEGS)
#define LPNS_PER_SEGMENT	(1024)
#define SEGMENT_COUNT       (TOTAL_LPN_COUNT / LPNS_PER_SEGMENT)

// INIT: 두 버퍼 모두 할당/0클리어
void TrimBitmap_Init(void)
{
    // 1. 메인 Trim 비트맵 메모리 할당 및 0으로 초기화
    g_trim_bitmap = (volatile UINT8*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)TRIM_BITMAP_BYTES, /*align=*/64);
    DEBUG_ASSERT(g_trim_bitmap != NULL);
    OSAL_MEMSET((void*)g_trim_bitmap, 0, (UINT32)TRIM_BITMAP_BYTES);

    // 2. 세그먼트별 '카운트' 배열 할당 및 0으로 초기화
    UINT32 count_array_size = SEGMENT_COUNT * sizeof(UINT16);
    g_trim_seg_count = (volatile UINT16*)OSAL_MemAlloc(MEM_TYPE_BUF, (int)count_array_size, /*align=*/64);
    DEBUG_ASSERT(g_trim_seg_count != NULL);
    OSAL_MEMSET((void*)g_trim_seg_count, 0, count_array_size);
}

void SetTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        // 같은 세그먼트: 마스크로 한 번에 처리 (카운트 자동 반영)
        set_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    // 1) 앞 세그먼트의 끝까지 부분 set
    UINT32 head_end = seg_end_lpn(segS);
    set_range_same_segment(nStartLPN, head_end, segS);

    // 2) 중간 "완전 세그먼트"는 통째로 0xFF로 채우고 카운트를 LPNS_PER_SEGMENT로 바로 설정
    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8; // 일반적으로 딱 떨어짐
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0xFF, (size_t)seg_bytes);
        g_trim_seg_count[s] = LPNS_PER_SEGMENT; // 통째로 set
    }

    // 3) 마지막 세그먼트의 시작부터 nEndLPN까지 부분 set
    UINT32 tail_begin = seg_base_lpn(segE);
    set_range_same_segment(tail_begin, nEndLPN, segE);

    TrimPending_Set();
}

void ClearTrimRange(UINT32 nStartLPN, UINT32 nEndLPN)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nEndLPN < TOTAL_LPN_COUNT);

    UINT32 segS = nStartLPN / LPNS_PER_SEGMENT;
    UINT32 segE = nEndLPN   / LPNS_PER_SEGMENT;

    if (segS == segE) {
        // 같은 세그먼트: 마스크로 한 번에 처리 (카운트 자동 반영)
        clear_range_same_segment(nStartLPN, nEndLPN, segS);
        return;
    }

    // 1) 앞 세그먼트의 끝까지 부분 clear
    UINT32 head_end = seg_end_lpn(segS);
    clear_range_same_segment(nStartLPN, head_end, segS);

    // 2) 중간 "완전 세그먼트"는 통째로 0x00으로 채우고 카운트를 0으로 설정
    for (UINT32 s = segS + 1; s < segE; ++s) {
        UINT32 seg_base = seg_base_lpn(s);
        UINT32 seg_bytes = (LPNS_PER_SEGMENT + (8 - 1)) / 8;
        UINT32 base_byte = byte_idx_from_lpn(seg_base);
        memset_volatile_u8(&g_trim_bitmap[base_byte], (UINT8)0x00, (size_t)seg_bytes);
        g_trim_seg_count[s] = 0; // 통째로 clear
    }

    // 3) 마지막 세그먼트의 시작부터 nEndLPN까지 부분 clear
    UINT32 tail_begin = seg_base_lpn(segE);
    clear_range_same_segment(tail_begin, nEndLPN, segE);
}

void CheckPendingTrim()
{
    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i) // TRIM_SEGMENT_COUNT는 전체 세그먼트 개수를 의미하는 매크로로 가정
    {
        if (g_trim_seg_count[i] > 0)
        {
            return;
        }
    }
    TrimPending_Clear();
//    xil_printf("	TRIM CLEAN \r\n");
}

UINT32 FindTopKTrimSegments(UINT32 k)
{
    const u64 TICKS_PER_US = 500ULL;  // 5e8 / 1e6
    const u64 NS_PER_TICK  = 2ULL;    // 1 tick = 2 ns

    XTime t0, t1, t2, t3;
    u64 dt_phase1 = 0, dt_phase2 = 0;
    u32 us_p1 = 0, ns_p1 = 0, us_p2 = 0, ns_p2 = 0;

	UINT32 Load_CNT = 0;
    // 0. 유효성 검사
    if (k == 0) {
        return 0;
    }

    XTime_GetTime(&t0);

    // 1. Top K의 카운트와 인덱스를 저장할 임시 배열을 스택에 생성합니다.
    UINT16 anTopCounts[k];
    UINT32 anTopIndices[k];

    // 2. 임시 배열을 0으로 초기화합니다.
    OSAL_MEMSET(anTopCounts, 0, sizeof(UINT16) * k);
    OSAL_MEMSET(anTopIndices, 0, sizeof(UINT32) * k);

    UINT16 nMinCountInTopK = 0; // 현재 Top K 목록에 있는 카운트 중 '최소값'
    UINT32 nMinCountIdx = 0;    // 그 최소값의 위치

    // 3. 전체 세그먼트를 단 한 번만 순회합니다.
    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i)
    {
        UINT16 nCurrentCount = g_trim_seg_count[i];

        // 현재 세그먼트의 카운트가 Top K 목록의 최소값보다 작거나 같으면 무시합니다.
        if (nCurrentCount <= nMinCountInTopK) {
            continue;
        }

        // Top K 목록의 최소값을 현재 세그먼트 정보로 교체합니다.
        anTopCounts[nMinCountIdx] = nCurrentCount;
        anTopIndices[nMinCountIdx] = i;

        // 교체 후, Top K 목록의 새로운 최소값을 다시 찾습니다.
        nMinCountInTopK = anTopCounts[0];
        nMinCountIdx = 0;
        for (UINT32 j = 1; j < k; ++j) {
            if (anTopCounts[j] < nMinCountInTopK) {
                nMinCountInTopK = anTopCounts[j];
                nMinCountIdx = j;
            }
        }
    }

    UINT32 LOOP_CNT = 0;
    for (UINT32 i = 0; i < k; ++i)
    {
        META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
        UINT32 meta_base_lpn = anTopIndices[i] * 1024;
        UINT32 nMaxCount = anTopCounts[i];

        // 유효한 최대값(카운트 > 0)을 찾았다면 즉시 출력합니다.
        if (nMaxCount > 0)
        {
        	if (pstMetaMgr->IsMetaAvailable(meta_base_lpn) == FALSE)
        		Load_CNT++;

            while (pstMetaMgr->IsMetaAvailable(meta_base_lpn) == FALSE)
            {
            	LOOP_CNT += 1;
                pstMetaMgr->LoadMeta(meta_base_lpn, 1);

                META_REQUEST_INFO* pstMetaReqInfo = DFTL_GLOBAL::GetRequestMgr()->GetMetaRequestInfo();
                META_REQUEST* pstRequest;

                do {
                    REQUEST_MGR* pstReqMgr = DFTL_GLOBAL::GetInstance()->GetRequestMgr();
                    pstReqMgr->_ProcessMetaRequestWaitQ();

                    FIL_Run();

                    pstRequest = pstMetaReqInfo->GetDoneRequest();
                    if (pstRequest != NULL) {
                        pstRequest->Run();
                    }
                } while (pstRequest != NULL);
            }
        }
    }
//    xil_printf("	FindTopKTrimSegments [%u] INNER LOOP\r\n", LOOP_CNT);
    return Load_CNT;
}

//UINT32 FindTopKTrimSegments(UINT32 k)
//{
//    if (k == 0) return 0;
//
//    UINT32 issued = 0;
//
//    UINT16 anTopCounts[k];
//    UINT32 anTopIndices[k];
//    OSAL_MEMSET(anTopCounts, 0, sizeof(UINT16) * k);
//    OSAL_MEMSET(anTopIndices, 0, sizeof(UINT32) * k);
//
//    UINT16 nMinCountInTopK = 0;
//    UINT32 nMinCountIdx = 0;
//
//    for (UINT32 i = 0; i < SEGMENT_COUNT; ++i) {
//        UINT16 cnt = g_trim_seg_count[i];
//        if (cnt <= nMinCountInTopK) continue;
//
//        anTopCounts[nMinCountIdx]  = cnt;
//        anTopIndices[nMinCountIdx] = i;
//
//        nMinCountInTopK = anTopCounts[0];
//        nMinCountIdx    = 0;
//        for (UINT32 j = 1; j < k; ++j) {
//            if (anTopCounts[j] < nMinCountInTopK) {
//                nMinCountInTopK = anTopCounts[j];
//                nMinCountIdx    = j;
//            }
//        }
//    }
//
//    META_MGR* pstMetaMgr = DFTL_GLOBAL::GetMetaMgr();
//
//    for (UINT32 i = 0; i < k && issued < k; ++i)
//    {
//        UINT32 seg_idx   = anTopIndices[i];
//        UINT16 seg_count = anTopCounts[i];
//        if (seg_count == 0) continue;
//
//        UINT32 meta_base_lpn = seg_idx * 1024;
//
//        if (pstMetaMgr->IsMetaAvailable(meta_base_lpn))
//        {
////        	xil_printf("Meta Is Available\r\n");
//            continue;
//        }
//
//        if (pstMetaMgr->LoadMeta(meta_base_lpn, 1)) {
//            issued++;
//        }
//    }
//
//    if (issued < k)
//    {
//        const UINT16 threshold = nMinCountInTopK;
//
//        for (UINT32 i = 0; i < SEGMENT_COUNT && issued < k; ++i)
//        {
//            UINT16 cnt = g_trim_seg_count[i];
//            if (cnt < threshold) continue;
//
//            bool inTop = false;
//            for (UINT32 j = 0; j < k; ++j) {
//                if (anTopIndices[j] == i) { inTop = true; break; }
//            }
//            if (inTop) continue;
//
//            UINT32 meta_base_lpn = i * 1024;
//            if (pstMetaMgr->IsMetaAvailable(meta_base_lpn))
//                continue;
//
//            if (pstMetaMgr->LoadMeta(meta_base_lpn, 1)) {
//                issued++;
//            }
//        }
//    }
//
//    return issued;
//}


VIRTUAL BOOL
DFTL_GLOBAL::Format(VOID)
{
	BOOL	bRet;

	GetUserBlockMgr()->Format();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	GetMetaBlockMgr()->Format();
	bRet = GetMetaL2VMgr()->Format();
#endif

	bRet = GetMetaMgr()->Format();			// THIS MUST BE AT THE END OF FORMAT ROUTINE

	return bRet;
}

VIRTUAL VOID 
DFTL_GLOBAL::Run(VOID)
{
	FIL_Run();
	GetRequestMgr()->Run();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->CheckAndStartGC();
		}
	}
#endif
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetGCMgr(channel, way)->CheckAndStartGC();
		}
	}

	FIL_Run();
	GetRequestMgr()->Run();

#if (SUPPORT_META_DEMAND_LOADING == 1)
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetMetaGCMgr(channel, way)->Run();
		}
	}
#endif
	for (UINT32 channel = 0; channel < USER_CHANNELS; channel++) {
		for (UINT32 way = 0; way < USER_WAYS; way++) {
			GetGCMgr(channel, way)->Run();
		}
	}
}

/*
	@brief	Add HIL read request to waitQ
*/
VIRTUAL VOID
DFTL_GLOBAL::ReadPage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;

	if ((nLPN == 77) && ((nCount == 77)|| (nCount == 78)))
	{
		DFTL_PrintProfile();
		m_bDSMEnable += 1;
	}

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);

//	if (DFTL_GLOBAL::GetInstance()->m_bDSMEnable > 1)
//		xil_printf("	HIL_REQUEST_READ nLPN(%u), nCount(%u)\r\n", nLPN, nCount);

	pstRequest->Initialize(HIL_REQUEST_READ_WAIT, NVME_CMD_OPCODE_READ, 
						nLPN, nCmdSlotTag, nCount);
#ifndef WIN32
	//xil_printf("1	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_read, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_READ_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::WritePage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount)
{
	HIL_REQUEST*	pstRequest;
	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);


//	if (DFTL_GLOBAL::GetInstance()->m_bDSMEnable > 1)
//		xil_printf("	HIL_REQUEST_WRITE nLPN(%u), nCount(%u)\r\n", nLPN, nCount);

	pstRequest->Initialize(HIL_REQUEST_WRITE_WAIT, NVME_CMD_OPCODE_WRITE, 
		nLPN, nCmdSlotTag, nCount);
#ifndef WIN32
	//xil_printf("7	%u	%u \r\n", nLPN, nCount);
#endif
	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_write, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_WRITE_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::DatasetManagement(UINT32 nCmdSlotTag, UINT32 nr, UINT32 ad)
{
	HIL_REQUEST*	pstRequest;

	do
	{
		// allocate request
		pstRequest = m_stRequestMgr.AllocateHILRequest();
		if (pstRequest == NULL)
		{
			Run();
		}
	} while (pstRequest == NULL);


//	if (DFTL_GLOBAL::GetInstance()->m_bDSMEnable > 1)
//		xil_printf("	HIL_REQUEST_DSM NR(%u)\r\n", nr);

	pstRequest->Initialize(HIL_REQUEST_DSM_WAIT, NVME_CMD_OPCODE_DSM,
		ad, nCmdSlotTag, nr);

	// add to waitQ
	m_stRequestMgr.AddToHILRequestWaitQ(pstRequest);

	DFTL_IncreaseProfile(Prof_Host_Discard);
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM, pstRequest->GetLPNCount());
	DFTL_GLOBAL::GetInstance()->IncreaseProfileCount(PROFILE_HOST_DSM_REQ);
}

VIRTUAL VOID
DFTL_GLOBAL::CallBack(FTL_REQUEST_ID stReqID)
{
#if (UNIT_TEST_FIL_PERF == 1)
	return;
#endif

	switch (stReqID.stCommon.nType)
	{
	case FTL_REQUEST_ID_TYPE_HIL_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		HIL_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetHILRequestInfo();
		HIL_REQUEST_PER_WAY * pstRequest = pstRequestInfo->GetRequest_per_way(stReqID.stHIL.nRequestIndex);

		pstRequest->IncreaseDoneCount();
		pstRequest->pBufEntry[stReqID.stHIL.bufOffset]->readDone = 1;

		if (pstRequest->GetDoneCount() == pstRequest->GetLPNCount())
		{
			// all read done  
			// remove from issued Q
			pstRequestInfo->RemoveFromIssuedQ_per_way(pstRequest);

			pstRequest->HDMAIssue();

			// add to done Q
			pstRequestInfo->AddToDoneQ_per_way(pstRequest);		// wait for HDMA Issue

			pstRequest->GoToNextStatus();		// NAND Issued -> NAND_DONE
		}

		break;
	}
	case FTL_REQUEST_ID_TYPE_WRITE:
	{
		// Pysical page program done
		INT32	nIndex = stReqID.stProgram.nActiveBlockIndex;
		IOTYPE	eIOType = static_cast<IOTYPE>(stReqID.stProgram.nIOType);

		ACTIVE_BLOCK* pstActiveBlock = DFTL_GLOBAL::GetActiveBlockMgr(stReqID.channel, stReqID.way)->GetActiveBlock(nIndex, eIOType);
		pstActiveBlock->ProgramDone(stReqID.stProgram.nBufferingIndex);
		break;
	}
	case FTL_REQUEST_ID_TYPE_GC_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		GC_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetGCRequestInfo();
		GC_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stGC.nRequestIndex);
		pstRequest->GCReadDone();
		break;
	}
#if (SUPPORT_META_DEMAND_LOADING == 1)
	case FTL_REQUEST_ID_TYPE_META_READ:
	{
		REQUEST_MGR*	pstRequestMgr = DFTL_GLOBAL::GetRequestMgr();
		META_REQUEST_INFO*	pstRequestInfo = pstRequestMgr->GetMetaRequestInfo();
		META_REQUEST * pstRequest = pstRequestInfo->GetRequest(stReqID.stMeta.nRequestIndex);

		pstRequestInfo->RemoveFromIssuedQ(pstRequest);
		pstRequestInfo->AddToDoneQ(pstRequest);
		pstRequest->GoToNextStatus();					// NAND Issued -> NAND_DONE

		break;
	}
#endif
	default:
		ASSERT(0);
		break;
	}
}

VIRTUAL VOID 
DFTL_GLOBAL::IOCtl(IOCTL_TYPE eType)
{
	switch (eType)
	{
	case IOCTL_INIT_PROFILE_COUNT:
		m_stProfile.Initialize();
		break;

	case IOCTL_PRINT_PROFILE_COUNT:
		m_stProfile.Print();
		break;

	default:
		ASSERT(0);		// unknown type
		break;
	}

	return;
}

VOID
DFTL_GLOBAL::SetStatus(DFTL_STATUS eStatus)
{
	m_eStatus = static_cast<DFTL_STATUS>(m_eStatus | eStatus);
}

BOOL
DFTL_GLOBAL::CheckStatus(DFTL_STATUS eStatus)
{
	return (m_eStatus & eStatus) ? TRUE : FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	static function
//

VOID 
DFTL_GLOBAL::_Initialize(VOID)
{
	UINT32 nPPagesPerVBlock = m_stVNand.GetPPagesPerVBlock();
	m_nPhysicalFlashSizeKB = USER_CHANNELS * USER_WAYS * m_stVNand.GetVBlockCount() * nPPagesPerVBlock * (PHYSICAL_PAGE_SIZE / KB);

	m_nVBlockSizeKB			= nPPagesPerVBlock * PHYSICAL_PAGE_SIZE;
	m_nVPagesPerVBlock		= m_stVNand.GetVPagesPerVBlock();
	m_nLPagesPerVBlockBits	= UTIL_GetBitCount(m_nVPagesPerVBlock);
	m_nLPagesPerVBlockMask	= (1 << m_nLPagesPerVBlockBits) - 1;

	m_fOverProvisionRatio = (float)OVERPROVISION_RATIO_DEFAULT;
	m_nOverprovisionSizeKB = (INT64)(m_nPhysicalFlashSizeKB * m_fOverProvisionRatio);
	m_nLogicalFlashSizeKB = m_nPhysicalFlashSizeKB - m_nOverprovisionSizeKB;

#if (SUPPORT_STATIC_DENSITY != 0)
	UINT32 nLogicalFlashSizeKB = SUPPORT_STATIC_DENSITY * (GB / KB);

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);

	m_nLogicalFlashSizeKB = nLogicalFlashSizeKB;		// update logical flash size

	ASSERT(m_nLogicalFlashSizeKB >= nLogicalFlashSizeKB);
#endif

	m_nLPNCount			= m_nLogicalFlashSizeKB / LOGICAL_PAGE_SIZE_KB;

	m_nVBlockCount		= m_stVNand.GetVBlockCount();

#if (SUPPORT_META_BLOCK == 1)
	m_bEnableMetaBlock = TRUE;
#else
	m_bEnableMetaBlock = FALSE;
#endif

	m_nGCTh = FREE_BLOCK_GC_THRESHOLD_DEFAULT;

	HIL_SetStorageBlocks(m_nLPNCount);

	m_stProfile.Initialize();
}

VOID 
DFTL_GLOBAL::_PrintInfo(VOID)
{
#if defined(FPM_FTL)
	char	psFTL[] = "FPMFTL";
#elif defined(DFTL)
	char	psFTL[] = "DFTL";
#else
#error check config
#endif

	PRINTF("[%s] Physical Density: %d MB \n\r", psFTL, m_nPhysicalFlashSizeKB / KB);
	PRINTF("[%s] Logical Density: %d MB \n\r", psFTL, m_nLogicalFlashSizeKB / KB);
}

VOID Read_Cache::Initialize()
{
	for (int i = 0; i < MAX_READ_CACHE_ENTRY; i++)
	{
		source_lpn[i] = 0xffffffff;
		nVPPN[i] = 0xffffffff;
		Buf[i] = DFTL_GLOBAL::GetBufferMgr()->Allocate();
		if (Buf[i] == NULL)
			ASSERT(0);
		Buf[i]->readDone = 1;
	}

	return VOID();
}

BUFFER_ENTRY * Read_Cache::change_next_buffer(UINT32 src_lpn, BUFFER_ENTRY * input_buf)
{
	BUFFER_ENTRY * ret;

	UINT32 iter;
	UINT32 channel, way;
	channel = get_channel_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
	way = get_way_from_lpn(src_lpn << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;

	for (iter = start_offset; iter < end_offset; iter++)
	{
		if (Buf[iter]->refCount == 0)
		{
			break;
		}
	}
	if (iter == end_offset)
		return NULL;

	ret = Buf[iter];
	source_lpn[iter] = src_lpn;
	Buf[iter] = input_buf;
	nVPPN[iter] = input_buf->nVPPN >> NUM_BIT_LPN_PER_PAGE;
	return ret;
}


BUFFER_ENTRY * Read_Cache::get_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
			return Buf[iter];
	}
	return NULL;
}

VOID Read_Cache::free_buffer_by_VPPN(UINT32 nVPPN_input)
{
	UINT32 channel, way;
	channel = CHANNEL_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	way = WAY_FROM_VPPN(nVPPN_input << NUM_BIT_LPN_PER_PAGE);
	UINT32 start_offset, end_offset;
	way += channel << NUM_BIT_WAY;
	start_offset = way << READ_CAHCE_PER_WAY_BIT;
	end_offset = (way + 1) << READ_CAHCE_PER_WAY_BIT;
	for (int iter = start_offset; iter < end_offset; iter++)
	{
		if (nVPPN_input == nVPPN[iter])
		{
			Buf[iter]->nVPPN = 0xffffffff;
			nVPPN[iter] = 0xffffffff;
			return;
		}
	}
}
