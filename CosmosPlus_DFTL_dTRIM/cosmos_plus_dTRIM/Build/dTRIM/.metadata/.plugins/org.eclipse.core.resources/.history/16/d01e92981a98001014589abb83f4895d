/*******************************************************
*
* Copyright (C) 2018-2019 
* Embedded Software Laboratory(ESLab), SUNG KYUN KWAN UNIVERSITY
* 
* This file is part of ESLab's Flash memory firmware
* 
* This source can not be copied and/or distributed without the express
* permission of ESLab
*
* Author: DongYoung Seo (dongyoung.seo@gmail.com)
		  Kyuhwa Han (hgh6877@gmail.com)
* ESLab: http://nyx.skku.ac.kr
*
*******************************************************/

#ifndef __DFTL_GLOBAL_H__
#define __DFTL_GLOBAL_H__

#ifndef TB_SEG_LPNS
#define TB_SEG_LPNS (1024u)
#endif

#ifndef TOTAL_LPN_COUNT
#define TOTAL_LPN_COUNT ( \
		(unsigned long long)(USER_CHANNELS) * \
		(unsigned long long)(USER_WAYS) * \
		(unsigned long long)(MAIN_BLOCKS_PER_DIE) * \
		(unsigned long long)(PAGES_PER_BLOCK) * \
		(unsigned long long)(LPN_PER_PHYSICAL_PAGE) )
#endif

extern volatile UINT8* g_trim_bitmap;      // LPN 비트맵(그대로 유지)
extern volatile UINT16* g_trim_seg_count;
extern volatile UINT32 g_trim_pending;
extern volatile UINT32 g_trim_going;


void TrimBitmap_Init(void);             // 할당 + 0클리어
VOID SetTrimRange(UINT32 nStartLPN, UINT32 nEndLPN);
VOID ClearTrimRange(UINT32 nStartLPN, UINT32 nEndLPN);
UINT32 FindTopKTrimSegments(UINT32 k);
UINT32 FindTopKTrimSegments(UINT32 k, UINT32* out_ids, UINT16* out_counts);
void CheckPendingTrim();

static inline void TrimPending_Clear(void) { g_trim_pending = 0; }
static inline void TrimPending_Set(void) { g_trim_pending = 1; }
static inline int TrimPending_IsOn(void)
{
    return g_trim_pending;
}

static inline void memset_volatile_u8(volatile UINT8* dst, UINT8 value, size_t len)
{
    for (size_t i = 0; i < len; ++i) dst[i] = value;
}

static inline UINT32 popcount8(UINT8 x)
{
    // 8-bit popcount (portable)
    x = x - ((x >> 1) & 0x55);
    x = (x & 0x33) + ((x >> 2) & 0x33);
    return (UINT32)(((x + (x >> 4)) & 0x0F));
}

static inline UINT32 seg_base_lpn(UINT32 seg_idx) { return seg_idx * 1024; }
static inline UINT32 seg_end_lpn (UINT32 seg_idx) { return seg_base_lpn(seg_idx) + 1024 - 1; }
static inline UINT32 byte_idx_from_lpn(UINT32 lpn) { return lpn / 8; }
static inline UINT32 bit_off_from_lpn (UINT32 lpn) { return lpn % 8; }

static void set_range_same_segment(UINT32 nStartLPN, UINT32 nEndLPN, UINT32 seg_idx)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nStartLPN / LPNS_PER_SEGMENT == nEndLPN / LPNS_PER_SEGMENT);

    UINT32 bStart = byte_idx_from_lpn(nStartLPN);
    UINT32 bEnd   = byte_idx_from_lpn(nEndLPN);
    UINT32 bitS   = bit_off_from_lpn(nStartLPN);
    UINT32 bitE   = bit_off_from_lpn(nEndLPN);

    INT32 delta = 0;

    if (bStart == bEnd) {
        UINT8 mask = (UINT8)((0xFFu << bitS) & (0xFFu >> (7u - bitE)));
        UINT8 oldb = g_trim_bitmap[bStart];
        UINT8 newb = (UINT8)(oldb | mask);
        g_trim_bitmap[bStart] = newb;
        delta += (INT32)popcount8(newb) - (INT32)popcount8(oldb);
    } else {
        // 시작 바이트
        {
            UINT8 maskStart = (UINT8)(0xFFu << bitS);
            UINT8 oldb = g_trim_bitmap[bStart];
            UINT8 newb = (UINT8)(oldb | maskStart);
            g_trim_bitmap[bStart] = newb;
            delta += (INT32)popcount8(newb) - (INT32)popcount8(oldb);
        }
        // 중간 바이트(전부 1로)
        for (UINT32 b = bStart + 1; b < bEnd; ++b) {
            UINT8 oldb = g_trim_bitmap[b];
            if (oldb != 0xFFu) {
                delta += 8 - (INT32)popcount8(oldb);
                g_trim_bitmap[b] = 0xFFu;
            }
        }
        // 끝 바이트
        {
            UINT8 maskEnd = (UINT8)(0xFFu >> (7u - bitE));
            UINT8 oldb = g_trim_bitmap[bEnd];
            UINT8 newb = (UINT8)(oldb | maskEnd);
            g_trim_bitmap[bEnd] = newb;
            delta += (INT32)popcount8(newb) - (INT32)popcount8(oldb);
        }
    }

    if (delta > 0) {
        g_trim_seg_count[seg_idx] += (UINT32)delta;
    }
}

// 같은 세그먼트 내의 [start, end] 범위를 "clear" 하며 세그 카운트를 감소
static void clear_range_same_segment(UINT32 nStartLPN, UINT32 nEndLPN, UINT32 seg_idx)
{
    DEBUG_ASSERT(nStartLPN <= nEndLPN);
    DEBUG_ASSERT(nStartLPN / LPNS_PER_SEGMENT == nEndLPN / LPNS_PER_SEGMENT);

    UINT32 bStart = byte_idx_from_lpn(nStartLPN);
    UINT32 bEnd   = byte_idx_from_lpn(nEndLPN);
    UINT32 bitS   = bit_off_from_lpn(nStartLPN);
    UINT32 bitE   = bit_off_from_lpn(nEndLPN);

    INT32 delta = 0;

    if (bStart == bEnd) {
        UINT8 mask = (UINT8)((0xFFu << bitS) & (0xFFu >> (7u - bitE)));
        UINT8 oldb = g_trim_bitmap[bStart];
        UINT8 newb = (UINT8)(oldb & ~mask);
        g_trim_bitmap[bStart] = newb;
        delta += (INT32)popcount8(oldb) - (INT32)popcount8(newb);
    } else {
        // 시작 바이트
        {
            UINT8 maskStart = (UINT8)(0xFFu << bitS);
            UINT8 oldb = g_trim_bitmap[bStart];
            UINT8 newb = (UINT8)(oldb & ~maskStart);
            g_trim_bitmap[bStart] = newb;
            delta += (INT32)popcount8(oldb) - (INT32)popcount8(newb);
        }
        // 중간 바이트(전부 0으로)
        for (UINT32 b = bStart + 1; b < bEnd; ++b) {
            UINT8 oldb = g_trim_bitmap[b];
            if (oldb != 0x00u) {
                delta += (INT32)popcount8(oldb); // 모두 지워지므로 old popcount만큼 감소
                g_trim_bitmap[b] = 0x00u;
            }
        }
        // 끝 바이트
        {
            UINT8 maskEnd = (UINT8)(0xFFu >> (7u - bitE));
            UINT8 oldb = g_trim_bitmap[bEnd];
            UINT8 newb = (UINT8)(oldb & ~maskEnd);
            g_trim_bitmap[bEnd] = newb;
            delta += (INT32)popcount8(oldb) - (INT32)popcount8(newb);
        }
    }

    // delta는 '지워진 비트 수'
    DEBUG_ASSERT(g_trim_seg_count[seg_idx] >= (UINT32)delta);
    if (delta > 0) {
        g_trim_seg_count[seg_idx] -= (UINT32)delta;
    }
//    xil_printf("SEG[%u] have [%u]bits \r\n", seg_idx, g_trim_seg_count[seg_idx]);
}

#define get_channel_from_lpn(lpn)	(((lpn) >> NUM_BIT_LPN_PER_PAGE) % USER_CHANNELS)
#ifdef CH_WY_FLAX
#define get_way_from_lpn(lpn)		((((lpn) >> NUM_BIT_LPN_PER_PAGE) / USER_CHANNELS) % USER_WAYS)
#define get_page_from_lpn(lpn)		((((lpn) >> NUM_BIT_LPN_PER_PAGE) / (USER_CHANNELS * USER_WAYS)) & NAND_ADDR_PPAGE_MASK)
#define get_lbn_from_lpn(lpn)		(((((lpn) >> NUM_BIT_LPN_PER_PAGE) / (USER_CHANNELS * USER_WAYS)) >> (NUM_BIT_PPAGE)) & NAND_ADDR_BLOCK_MASK)
#else
#define get_way_from_lpn(lpn)		((((lpn) >> NUM_BIT_LPN_PER_PAGE) >> (CHANNEL_BITS)) % USER_WAYS)
#define get_page_from_lpn(lpn)		((((lpn) >> NUM_BIT_LPN_PER_PAGE) >> (CHANNEL_BITS + NUM_BIT_WAY)) & NAND_ADDR_PPAGE_MASK)
#define get_lbn_from_lpn(lpn)		((((lpn) >> NUM_BIT_LPN_PER_PAGE) >> (CHANNEL_BITS + NUM_BIT_WAY + NUM_BIT_PPAGE)) & NAND_ADDR_BLOCK_MASK)
#endif

#define BLOCKS_PER_MAP_PAGES		(L2V_PER_META_PAGE >> NUM_BIT_VPAGE))		//4096 div 512
#define BLOCKS_PER_MAP_BITS			(3)
#define BLOCKS_PER_MAP_MASKS		((1 << BLOCKS_PER_MAP_BITS) - 1)

#ifdef CH_WY_FLAX
//Channel -> Way -> Block -> Page -> Offset
#define get_mod_lpn_from_lpn_lbn(nCh, nWy, nBlock, nPage) ((nPage << NUM_BIT_LPN_PER_PAGE)  \
											+ ((nBlock & BLOCKS_PER_MAP_MASKS) << (NUM_BIT_VPAGE)) \
											+ (nWy << (NUM_BIT_VPAGE + BLOCKS_PER_MAP_BITS)) \
											+ ((nCh << (NUM_BIT_VPAGE + BLOCKS_PER_MAP_BITS)) * USER_WAYS) \
											+ (((nBlock >> BLOCKS_PER_MAP_BITS) << (NUM_BIT_VPAGE + BLOCKS_PER_MAP_BITS)) * USER_CHANNELS * USER_WAYS))
#else
#define get_mod_lpn_from_lpn_lbn(nCh, nWy, nBlock, nPage) ((nPage << NUM_BIT_LPN_PER_PAGE)  \
											+ ((nBlock & BLOCKS_PER_MAP_MASKS) << (NUM_BIT_VPAGE)) \
											+ (nWy << (NUM_BIT_VPAGE + BLOCKS_PER_MAP_BITS)) \
											+ (nCh << (NUM_BIT_VPAGE + BLOCKS_PER_MAP_BITS + NUM_BIT_WAY)) \
											+ ((nBlock >> BLOCKS_PER_MAP_BITS) << (NUM_BIT_VPAGE + BLOCKS_PER_MAP_BITS + CHANNEL_BITS + NUM_BIT_WAY)))
#endif

#define ADDR_PRINT_PROFILE		(8288)

#define READ_CAHCE_PER_WAY_BIT		(3)
#define READ_CACHE_PER_WAY			(8)
#define MAX_READ_CACHE_ENTRY		(USER_CHANNELS * USER_WAYS * READ_CACHE_PER_WAY)
class Read_Cache
{
public:
	VOID	Initialize();
	BUFFER_ENTRY *change_next_buffer(UINT32 src_lpn, BUFFER_ENTRY* input_buf);
	BUFFER_ENTRY *get_buffer_by_VPPN(UINT32 nVPPN_input);
	VOID free_buffer_by_VPPN(UINT32 nVPPN_input);
private:
	UINT32 source_lpn[MAX_READ_CACHE_ENTRY];
	UINT32 nVPPN[MAX_READ_CACHE_ENTRY];
	BUFFER_ENTRY* Buf[MAX_READ_CACHE_ENTRY];
};




class FTL_INTERFACE;
class VNAND;
class META_MGR;

class PROFILE
{
public:
	VOID Initialize(VOID)
	{
		for (INT32 i = 0; i < PROFILE_COUNT; i++)
		{
			m_astStatistics[i].nType = static_cast<PROFILE_TYPE>(i);
			m_astStatistics[i].nCount = 0;
		}
	}

	VOID IncreaseCount(PROFILE_TYPE eType)
	{
		IncreaseCount(eType, 1);
	}

	VOID IncreaseCount(PROFILE_TYPE eType, UINT32 nCount)
	{
		m_astStatistics[eType].nCount += nCount;
	}

	UINT32 GetCount(PROFILE_TYPE eType)
	{
		return m_astStatistics[eType].nCount;
	}

	VOID Print(VOID)
	{
		static const char *apsProfileString[] =
		{
			FOREACH_PROFILE(GENERATE_STRING)
		};

		for (int i = 0; i < PROFILE_COUNT; i++)
		{
			PRINTF("%s, %d\n\r", apsProfileString[i], GetCount((PROFILE_TYPE)i));
		}
	}


private:
	PROFILE_ENTRY	m_astStatistics[PROFILE_COUNT];
};

typedef enum
{
	DFTL_STATUS_NONE		= 0x00,
	DFTL_STATUS_META_IO		= 0x01,			// meta loading / storing
	DFTL_STATUS_FORMATTING	= 0x02,			// now formatting
} DFTL_STATUS;

class DFTL_GLOBAL : public FTL_INTERFACE
{
public:
	//DFTL_GLOBAL() {};

	VIRTUAL VOID Initialize(VOID);
	VIRTUAL BOOL Format(VOID);
	VIRTUAL VOID Run(VOID);
	VIRTUAL VOID ReadPage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount);
	VIRTUAL VOID WritePage(UINT32 nCmdSlotTag, UINT32 nLPN, UINT32 nCount);
	VIRTUAL VOID DatasetManagement(UINT32 nCmdSlotTag, UINT32 NR, UINT32 AD);
	VIRTUAL VOID CallBack(FTL_REQUEST_ID stReqID);
	VIRTUAL VOID IOCtl(IOCTL_TYPE eType);

	static DFTL_GLOBAL*		GetInstance(VOID) { return m_pstInstance; }
	static VNAND*			GetVNandMgr(VOID) { return &m_pstInstance->m_stVNand; }
	static BLOCK_MGR*		GetUserBlockMgr(VOID) { return &m_pstInstance->m_stUserBlockMgr; }
#if (SUPPORT_META_DEMAND_LOADING == 1)
	static BLOCK_MGR*		GetMetaBlockMgr(VOID) { return &m_pstInstance->m_stMetaBlockMgr; }
#endif
	static VBINFO_MGR*		GetVBInfoMgr(UINT32 channel, UINT32 way) { return &m_pstInstance->m_stVBInfoMgr[channel][way]; }
	static REQUEST_MGR*		GetRequestMgr(VOID)	{return &m_pstInstance->m_stRequestMgr;}
	static GC_MGR*			GetGCMgr(UINT32 channel, UINT32 way) { return &m_pstInstance->m_stGCMgr[channel][way]; }
#if (SUPPORT_META_DEMAND_LOADING == 1)
	static GC_MGR*			GetMetaGCMgr(UINT32 channel, UINT32 way) { return &m_pstInstance->m_stMetaGCMgr[channel][way]; }
#endif
	static ACTIVE_BLOCK_MGR* GetActiveBlockMgr(UINT32 channel, UINT32 way) { return &m_pstInstance->m_stActiveBlockMgr[channel][way]; }
	static BUFFERING_LPN*	GetActiveBlockBufferingLPN(UINT32 channel, UINT32 way) { return m_pstInstance->m_stActiveBlockMgr[channel][way].GetBufferingMgr(); }

	static BUFFERING_LPN* GetMetaActiveBlockBufferingLPN(UINT32 channel, UINT32 way) { return m_pstInstance->m_stActiveBlockMgr[channel][way].GetMetaBufferingMgr(); }

	static META_MGR*		GetMetaMgr(VOID) { return &m_pstInstance->m_stMetaMgr; }
	static META_L2V_MGR*	GetMetaL2VMgr(VOID) { return &m_pstInstance->m_stMetaL2VMgr; }
	static BUFFER_MGR*		GetBufferMgr()	{return &m_pstInstance->m_stBufferMgr;}
	static HDMA*			GetHDMAMgr(VOID)	{return &m_pstInstance->m_stHostDMA;}

	static Read_Cache*		GetReadCacheMgr() { return &m_pstInstance->m_stReadCache; }

	UINT32 GetVPagePerVBlock(VOID) {return m_nVPagesPerVBlock;}

	UINT32 GetLPNCount(VOID) {return m_nLPNCount;}
	BOOL	IsValidLPN(UINT32 nLPN)
	{
		return (nLPN < m_nLPNCount) ? TRUE : FALSE;
	}

	VOID IncreaseProfileCount(PROFILE_TYPE eType)
	{
		m_stProfile.IncreaseCount(eType);
	}

	VOID IncreaseProfileCount(PROFILE_TYPE eType, UINT32 nCount)
	{
		m_stProfile.IncreaseCount(eType, nCount);
	}

	UINT32 GetProfileCount(PROFILE_TYPE eType)
	{
		return m_stProfile.GetCount(eType);
	}

	UINT32 GetGCTh(VOID) { return m_nGCTh; }

	VOID SetStatus(DFTL_STATUS eStatus);
	BOOL CheckStatus(DFTL_STATUS eStatus);

	VOID SetMetaGCing() { m_MetaGCing = TRUE; }
	VOID ClearMetaGCing() { m_MetaGCing = FALSE; }
	BOOL isMetaGCing() { return m_MetaGCing;}

private:		// fuctions
	VOID _Initialize(VOID);

private:
	VOID _PrintInfo(VOID);

	static DFTL_GLOBAL*	m_pstInstance;

	VNAND				m_stVNand;				// virtual nand module
	META_MGR			m_stMetaMgr;			// meta moudle
	META_L2V_MGR		m_stMetaL2VMgr;			// met data location
	BLOCK_MGR			m_stUserBlockMgr;		// block module

	BLOCK_MGR			m_stMetaBlockMgr;		// block module

	VBINFO_MGR			m_stVBInfoMgr[USER_CHANNELS][USER_WAYS];			// Virtual Information Manager
	REQUEST_MGR			m_stRequestMgr;			// read/write request manager
	GC_MGR				m_stGCMgr[USER_CHANNELS][USER_WAYS];				// garbage collector
#if (SUPPORT_META_DEMAND_LOADING == 1)
	GC_MGR				m_stMetaGCMgr[USER_CHANNELS][USER_WAYS];			// meta garbage collector
#endif
	ACTIVE_BLOCK_MGR	m_stActiveBlockMgr[USER_CHANNELS][USER_WAYS];
	BUFFER_MGR			m_stBufferMgr;
	HDMA				m_stHostDMA;

	DFTL_STATUS	m_eStatus;

	PROFILE		m_stProfile;

	UINT32		m_nPhysicalFlashSizeKB;
	UINT32		m_nVBlockSizeKB;
	UINT32		m_nVPagesPerVBlock;
	UINT32		m_nLPagesPerVBlockBits;
	UINT32		m_nLPagesPerVBlockMask;

	float		m_fOverProvisionRatio;
	UINT32		m_nOverprovisionSizeKB;
	UINT32		m_nLogicalFlashSizeKB;

	UINT32		m_nLPNCount;
	UINT32		m_nVBlockCount;

	UINT32		m_nGCTh;				// free block count for GC trigger

	BOOL		m_bEnableMetaBlock;

	BOOL		m_MetaGCing;


	Read_Cache			m_stReadCache;

public:
	int 		m_bDSMEnable = -1;
};

#endif		// end of #ifndef __DFTL_H__
